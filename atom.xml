<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fang&#39;Blog</title>
  
  <subtitle>心有猛虎，细嗅蔷薇。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanguvw.xyz/"/>
  <updated>2018-10-09T14:14:23.091Z</updated>
  <id>http://fanguvw.xyz/</id>
  
  <author>
    <name>Fang Zhen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步（sync）与异步(async)编程</title>
    <link href="http://fanguvw.xyz/2018/10/09/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://fanguvw.xyz/2018/10/09/同步与异步编程/</id>
    <published>2018-10-09T14:00:30.000Z</published>
    <updated>2018-10-09T14:14:23.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><pre><code>同步：在进程中任务未结束时需等待结束才能执行下一个任务 异步：在进程中任务未结束但在等待的过程中可先去执行下一个任务js是属于单线程，所以我们最好采用异步编程单线程：所有的任务由一个线程来完成  多线程：多个任务可分配给不同的线程来完成</code></pre><h2 id="js中的异步编程："><a href="#js中的异步编程：" class="headerlink" title="js中的异步编程："></a>js中的异步编程：</h2><pre><code>1.定时器属于异步编程（到时间点后才开始执行，当时间设置为0也不会立即执行=&gt; 浏览器有延迟时间：谷歌：5~6ms IE：10~13ms）2.事件绑定属于异步编程（事件触发时才执行）3.回调函数也可理解为异步编程4.在AJAX中可以使用异步编程</code></pre><h2 id="同步异步案例理解"><a href="#同步异步案例理解" class="headerlink" title="同步异步案例理解"></a>同步异步案例理解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//案例一</span><br><span class="line">var count = 0;</span><br><span class="line">window.setTimeout(function () &#123;</span><br><span class="line">    count++;</span><br><span class="line">    console.log(count);//后输出=&gt;1  1000ms后</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(count); //先输出=&gt;0</span><br><span class="line">//案例二</span><br><span class="line">var count = 0;</span><br><span class="line">window.setTimeout(function () &#123;</span><br><span class="line">    count++;</span><br><span class="line">    console.log(count);//后输出=&gt;1  不会立马执行，需要等待一段时间 谷歌：5~6ms IE：10~13ms </span><br><span class="line">&#125;,0);</span><br><span class="line">console.log(count); //先输出=&gt;0</span><br><span class="line">//案例三</span><br><span class="line">   var count = 0;</span><br><span class="line">window.setTimeout(function () &#123;</span><br><span class="line">    count++;</span><br><span class="line">    console.log(count); //不输出：因为线程一直被死循环占用，定时器需要一直等待着</span><br><span class="line">&#125;,1000);</span><br><span class="line">console.log(count); //先输出=&gt;0</span><br><span class="line">while(1)&#123;</span><br><span class="line">    //死循环</span><br><span class="line">&#125;</span><br><span class="line">//案例四</span><br><span class="line">window.setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;a&apos;); //再输出a</span><br><span class="line">&#125;,10);</span><br><span class="line">window.setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;b&apos;);  //先输出b  因为在等待队列中是按时间排序的 时间短的先执行 </span><br><span class="line">&#125;,6);</span><br><span class="line">var i=0;</span><br><span class="line">while(i&lt;1000000000)&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX中的同步与异步编程"><a href="#AJAX中的同步与异步编程" class="headerlink" title="AJAX中的同步与异步编程"></a>AJAX中的同步与异步编程</h2><pre><code>AJAX中的同步：当AJAX任务开始时（xhr.send），一直需要到 READY STATE===4的时候任务才结束，才可以执行下一个任务AJAX中的异步：当AJAX任务开始时（xhr.send），不需要等待READY STATE===4,期间可以执行其他任务，当READY STATE===时，再做相关操作</code></pre><h3 id="AJAX中的三部曲"><a href="#AJAX中的三部曲" class="headerlink" title="AJAX中的三部曲"></a>AJAX中的三部曲</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr=new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;/list&quot;,true);</span><br><span class="line">/*</span><br><span class="line">        xhr.onreadystatechange=function()&#123;</span><br><span class="line">            if(xhr.readystate===4&amp;&amp;xhr.status===200)&#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">xhr.send(null);//只有send之后AJAX任务（向服务器发送请求）才开始</span><br></pre></td></tr></table></figure><h2 id="AJAX中案例理解"><a href="#AJAX中案例理解" class="headerlink" title="AJAX中案例理解"></a>AJAX中案例理解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//案例一</span><br><span class="line">var xhr=new XMLHttpRequest(); //readyState===0</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,true); //readyState===1</span><br><span class="line">xhr.onreadystatechange=function()&#123;  //绑定事件</span><br><span class="line">    console.log(xhr.readyState); //输出： 2 3 4</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 </span><br><span class="line"></span><br><span class="line">//案例二</span><br><span class="line">var xhr=new XMLHttpRequest(); //readyState===0</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,false); //readyState===1</span><br><span class="line">xhr.onreadystatechange=function()&#123;  //绑定事件</span><br><span class="line">    console.log(xhr.readyState); //输出：4 （同步） 当请求结束 readyState==4时才输出  ajax本身是异步方法 （xhr保存开始时值1，当任务结束时值为4 状态码由1-&gt;4 输出4）</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 </span><br><span class="line"></span><br><span class="line">//案例三</span><br><span class="line">var xhr=new XMLHttpRequest(); //readyState===0</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,true); //readyState===1</span><br><span class="line">xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 </span><br><span class="line">xhr.onreadystatechange=function()&#123;  //绑定事件</span><br><span class="line">    console.log(xhr.readyState); //输出：2 3 4 （异步-&gt;不需要等待状态码为4 -&gt;直接执行以下任务）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//案例四</span><br><span class="line">var xhr=new XMLHttpRequest(); //readyState===0</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,false); //readyState===1</span><br><span class="line">xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 </span><br><span class="line">xhr.onreadystatechange=function()&#123;  //绑定事件</span><br><span class="line">    console.log(xhr.readyState); // 无输出 （同步-&gt;状态码已为4时才添加事件-&gt;状态码不再改变触发事件-&gt;无输出）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取服务器时间"><a href="#获取服务器时间" class="headerlink" title="获取服务器时间"></a>获取服务器时间</h2><pre><code>状态码（readyState）为2时就需进行的操作（需异步）  =&gt;如获取响应头中的服务器时间（Date）=&gt; 可应用于电商网站倒计时抢购（若用客户端时间则用户可更改客户端时间） 虽状态码为4时可获取服务器响应头中的时间，但状态码从2-&gt;3-&gt;4占大量时间 当状态码为2时获取可节省时间 减小时间误差 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); //readyState===0</span><br><span class="line">xhr.open(&quot;HEAD&quot;, &quot;./a.json&quot;, true); //readyState===1 </span><br><span class="line">xhr.setRequestHeader(&quot;H51806&quot;,&quot;fang&quot;); //客户端设置请求头信息到a.json上-&gt;服务器端获取 （需写在open方法后）</span><br><span class="line">xhr.timeout=&quot;1000&quot;;//设置AJAX请求的超时时间（若为同步编程，请求时间超过设置时间时放弃请求，执行下列任务）</span><br><span class="line">/*</span><br><span class="line">    常用HTTP方法：</span><br><span class="line">        GET:一般用于从服务器获取数据（给服务器数据少，获取数据多，此方法最常用）-&gt;问号传参</span><br><span class="line">        POST:一般用于推送数据给服务器（给服务器多，获取少）  -&gt;请求主体传参</span><br><span class="line">        PUT:一般用于给服务器增加资源文件（上传图片功能）</span><br><span class="line">        DELETE:一般用于从服务器删除资源文件</span><br><span class="line">        HEAD:一般用于获取服务器响应头信息</span><br><span class="line">    这些请求方式不管是哪一种都可以向服务器获得或者传递数据，且从本质意义上无区别，只是行业内被开发者人约定俗成了各自不同的用处，并非标准。</span><br><span class="line">*/</span><br><span class="line">xhr.onreadystatechange = function () &#123; //绑定事件</span><br><span class="line">        if (xhr.readyState === 2) &#123;</span><br><span class="line">            // xhr.getResponseHeader=&gt;客户端获取服务器的响应头信息 </span><br><span class="line">            var time = xhr.getResponseHeader(&quot;Date&quot;);  </span><br><span class="line">            console.log(time); //输出的为格林尼治时间（GMT）</span><br><span class="line">            console.log(new Date(time)); //输出为中国标准时间（GMT+0800）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;同步：在进程中任务未结束时需等待结束才能执行下一个任务 
异步：在进程中任务未结束但在等待的过程中可
      
    
    </summary>
    
      <category term="AJAX" scheme="http://fanguvw.xyz/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://fanguvw.xyz/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>AJAX中的HTTP请求方式</title>
    <link href="http://fanguvw.xyz/2018/10/07/HTTP-METHOD/"/>
    <id>http://fanguvw.xyz/2018/10/07/HTTP-METHOD/</id>
    <published>2018-10-07T06:24:25.000Z</published>
    <updated>2018-10-07T06:55:32.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-METHOD"><a href="#HTTP-METHOD" class="headerlink" title="HTTP METHOD"></a>HTTP METHOD</h2><pre><code>HTTP常用的几种请求方式：1.GET2.POST3.PUT4.DELETE5.HEAD</code></pre><p>这些请求方式不管是哪一种都可以向服务器请求获取数据或者传递数据，从本质上无区别，只是在行业内被开发人员约定俗成各自不同的用处，并非是一种标准。</p><h2 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h2><pre><code>1.GET:一般用于从服务器获取数据（给服务器数据少，获取数据多，此方法最为常用）2.POST:一般用于推送数据给服务器（给服务器多，获取数据少）3.PUT：一般用于向服务器传递资源文件（上传图片功能）4.DELETE:一般用于删除服务器资源文件5.HEAD:一般用于获取服务器响应头信息</code></pre><h2 id="GET-PK-POST"><a href="#GET-PK-POST" class="headerlink" title="GET PK POST"></a>GET PK POST</h2><p>传递方式：</p><pre><code>GET:向服务器传递内容一般通过&quot;URL问号传参方式&quot;xhr.open(&quot;GET&quot;,&quot;/getlist?a=2&amp;num=4&quot;,true);POST:向服务器传递内容一般通过&quot;请求主体的方式&quot;xhr.open(&quot;POST&quot;,&quot;/postlist&quot;,true);xhr.send(&apos;{&quot;name&quot;:&quot;fang&quot;,&quot;age&quot;:&quot;22&quot;}&apos;); //传递的为JSON对象格式的字符串</code></pre><p>大小问题：</p><pre><code>GET请求传递给服务器的内容存在大小限制，而POST理论上无限制（实际一般最大2MB）原因：GET是通过URL传参形式，而每个浏览器对URL长度有限制，谷歌8KB，火狐7KB，IE2KB,所以当兼容IE情况下最大上传2KB大小内容。</code></pre><p>缓存问题：</p><pre><code>GET请求会出现缓存 =&gt; 因为请求地址与传参相同（不一定是304），POST请求无缓存在项目中我们的GET请求一般不允许出现缓存 =&gt; “清除缓存” =&gt; 改变URL =&gt; 在URL末尾追加一个随机数 =&gt; xhr.open(&quot;GET&quot;,&quot;/getlist?a=2&amp;num=5&amp;_=&quot;+Math.random(),true);</code></pre><p>安全问题：</p><pre><code>一般来说GET不安全（URL传参）,而POST相对安全实际当攻击者想攻击时都不安全</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP-METHOD&quot;&gt;&lt;a href=&quot;#HTTP-METHOD&quot; class=&quot;headerlink&quot; title=&quot;HTTP METHOD&quot;&gt;&lt;/a&gt;HTTP METHOD&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;HTTP常用的几种请求方式：
1.GET
2.POS
      
    
    </summary>
    
      <category term="AJAX" scheme="http://fanguvw.xyz/categories/AJAX/"/>
    
    
      <category term="AJAX" scheme="http://fanguvw.xyz/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式（发布/订阅模式）</title>
    <link href="http://fanguvw.xyz/2018/10/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fanguvw.xyz/2018/10/02/观察者模式/</id>
    <published>2018-10-02T13:27:52.000Z</published>
    <updated>2018-10-02T13:49:56.303Z</updated>
    
    <content type="html"><![CDATA[<pre><code>观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。</code></pre><p>说的简单些，就是在数据发生改变时，对应的处理函数自动执行。维基的定义中涉及到了主动发出通知，按照这种方式，在angularJS中的事件广播更是中规中矩，但是其缺点是代码的可维护性较差。那么如果不进行主动通知，而是在进行对象属性值设置时，调用相关的处理函数，也可达到同等效果。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// 页面加载时自动执行</span><br><span class="line">       var Observer = (function() &#123;</span><br><span class="line">           // 为了防止消息被外部修改，将消息变量设为私有变量</span><br><span class="line">           var _message = &#123;&#125;;</span><br><span class="line">           return &#123;</span><br><span class="line">               // 注册信息接口</span><br><span class="line">               regist: function(type, fn) &#123;</span><br><span class="line">                   // 判断消息类型是否存在</span><br><span class="line">                   if (typeof _message[type] === &apos;undefined&apos;) &#123;</span><br><span class="line">                       // 将动作推送到消息队列中执行</span><br><span class="line">                       _message[type] = [fn];</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // 将动作方法推入到对应类型的队列中</span><br><span class="line">                       _message[type].push(fn);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;,</span><br><span class="line">               // 发布消息接口</span><br><span class="line">               fire: function(type, args) &#123;</span><br><span class="line">                   //如果该消息没有被注册，直接结束</span><br><span class="line">                   if (!_message[type]) return;</span><br><span class="line">                   var events = &#123;</span><br><span class="line">                       type: type, //消息的类型</span><br><span class="line">                       args: args || &#123;&#125; //消息所携带的数据</span><br><span class="line">                   &#125;</span><br><span class="line">                   i = 0, //消息循环变量</span><br><span class="line">                       len = _message[type].length; //消息动作的长度</span><br><span class="line">                   for (; i &lt; len; i++) &#123;</span><br><span class="line">                       //依次执行注册消息所对应的动作序列</span><br><span class="line">                       _message[type][i].call(this, events);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;,</span><br><span class="line">               // 移除信息接口</span><br><span class="line">               remove: function(type, fn) &#123;</span><br><span class="line">                   // 如果消息队列存在</span><br><span class="line">                   if (_message[type] instanceof Array) &#123;</span><br><span class="line">                       //从最后一个消息动作开始遍历</span><br><span class="line">                       var i = _message[type].length - 1;</span><br><span class="line">                       for (; i &gt;= 0; i--) &#123;</span><br><span class="line">                           _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)();</span><br><span class="line"></span><br><span class="line">       //订阅消息</span><br><span class="line"></span><br><span class="line">       Observer.regist(&apos;news&apos;, function(e) &#123;</span><br><span class="line">           console.log(e.type, e.args.msg);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Observer.regist(&apos;weather&apos;, function(e) &#123;</span><br><span class="line">           console.log(e.args.title);</span><br><span class="line">           console.log(e.args.msg);</span><br><span class="line">       &#125;);</span><br><span class="line">       Observer.regist(&apos;weather&apos;, function(e) &#123;</span><br><span class="line">           console.log(e.args.title);</span><br><span class="line">           console.log(e.args.msg);</span><br><span class="line">       &#125;);</span><br><span class="line">       //发布消息</span><br><span class="line">       Observer.fire(&apos;news&apos;, &#123;</span><br><span class="line">           msg: &apos;新闻主体内容&apos;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Observer.fire(&apos;weather&apos;, &#123;</span><br><span class="line">           title: &apos;杭州天气&apos;,</span><br><span class="line">           msg: &apos;晴转多云 21-36°C&apos;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       Observer.fire(&apos;weather&apos;, &#123;</span><br><span class="line">           title: &apos;上海天气&apos;,</span><br><span class="line">           msg: &apos;晴转多云 22-36°C&apos;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说的简单些，就是在数
      
    
    </summary>
    
      <category term="设计模式" scheme="http://fanguvw.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://fanguvw.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>AJAX兼容与惰性思想</title>
    <link href="http://fanguvw.xyz/2018/09/28/AJAX/"/>
    <id>http://fanguvw.xyz/2018/09/28/AJAX/</id>
    <published>2018-09-28T13:50:21.000Z</published>
    <updated>2018-09-28T14:21:32.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS编程技巧-惰性思想"><a href="#JS编程技巧-惰性思想" class="headerlink" title="JS编程技巧:惰性思想"></a>JS编程技巧:惰性思想</h2><pre><code>所谓的惰性思想可以简单地理解为:只执行一次可以搞定的事，绝不执行多次。</code></pre><h3 id="惰性思想代码块"><a href="#惰性思想代码块" class="headerlink" title="惰性思想代码块:"></a>惰性思想代码块:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var utils=(function()&#123;</span><br><span class="line">    var flag=&quot;getComputedStyle&quot; in window; //若返回true则为标准浏览器，false为IE8及以下浏览器 </span><br><span class="line">    function getCss()&#123;</span><br><span class="line">        if(flag)&#123;  //因为以上已判断此浏览器结果并保存,直接使用flag而不需要用window.getComputedStyle判断</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return&#123;</span><br><span class="line">        getCss:getCss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">utils.getCss(); </span><br><span class="line">utils.getCss();</span><br><span class="line">utils.getCss();</span><br></pre></td></tr></table></figure><h2 id="惰性思想创建AJAX对象"><a href="#惰性思想创建AJAX对象" class="headerlink" title="惰性思想创建AJAX对象"></a>惰性思想创建AJAX对象</h2><pre><code>利用函数创建且兼容所有浏览器</code></pre><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var createXHR = function () &#123;</span><br><span class="line">    var xhr = null,</span><br><span class="line">        flag=false, //判断浏览器是否支持AJAX</span><br><span class="line">        // 定义一个数组用于存放创建AJAX对象的各种方法</span><br><span class="line">        arr = [</span><br><span class="line">            function () &#123;</span><br><span class="line">                return new XMLHttpRequest(); //只兼容IE7及以上 </span><br><span class="line">            &#125;,</span><br><span class="line">            // 以下三种方法兼容低版本浏览器</span><br><span class="line">            function () &#123;</span><br><span class="line">                return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            function () &#123;</span><br><span class="line">                return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            function () &#123;</span><br><span class="line">                return new ActiveXObject(&quot;Msxml3.XMLHTTP&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        ];</span><br><span class="line">    //  遍历这个数组中的小方法,当可用时即可取用</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var curFn = arr[i]; //获取当前遍历到的小方法</span><br><span class="line">        try &#123;</span><br><span class="line">            // 本次循环获取的方法执行没有报错：说明此方法可用，下次直接执行此小方法即可=&gt;将createXHR重写为此小方法</span><br><span class="line">            xhr = curFn();</span><br><span class="line">            createXHR = curFn;    </span><br><span class="line">            flag = true; //浏览器可兼容AJAX则为true;</span><br><span class="line">            break; //结束循环</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            //本次获取的方法执行报错则继续循环遍历下一个方法</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123; </span><br><span class="line">            throw new Error(&quot;please updata your brower&quot;); //浏览器不支持AJAX时抛出错误</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return xhr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS编程技巧-惰性思想&quot;&gt;&lt;a href=&quot;#JS编程技巧-惰性思想&quot; class=&quot;headerlink&quot; title=&quot;JS编程技巧:惰性思想&quot;&gt;&lt;/a&gt;JS编程技巧:惰性思想&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;所谓的惰性思想可以简单地理解为:只执行一次可以搞定的
      
    
    </summary>
    
      <category term="Ajax" scheme="http://fanguvw.xyz/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://fanguvw.xyz/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>旋转的八卦图</title>
    <link href="http://fanguvw.xyz/2018/09/17/%E6%97%8B%E8%BD%AC%E7%9A%84%E5%85%AB%E5%8D%A6%E5%9B%BE/"/>
    <id>http://fanguvw.xyz/2018/09/17/旋转的八卦图/</id>
    <published>2018-09-17T13:31:30.000Z</published>
    <updated>2018-09-18T07:00:14.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用JS或CSS3结合Canvas实现八卦图旋转"><a href="#利用JS或CSS3结合Canvas实现八卦图旋转" class="headerlink" title="利用JS或CSS3结合Canvas实现八卦图旋转"></a>利用JS或CSS3结合Canvas实现八卦图旋转</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用JS或CSS3结合Canvas实现八卦图旋转&quot;&gt;&lt;a href=&quot;#利用JS或CSS3结合Canvas实现八卦图旋转&quot; class=&quot;headerlink&quot; title=&quot;利用JS或CSS3结合Canvas实现八卦图旋转&quot;&gt;&lt;/a&gt;利用JS或CSS3结合Can
      
    
    </summary>
    
      <category term="Canvas" scheme="http://fanguvw.xyz/categories/canvas/"/>
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/categories/canvas/jacascript/"/>
    
      <category term="Css" scheme="http://fanguvw.xyz/categories/canvas/jacascript/css/"/>
    
    
      <category term="Canvas" scheme="http://fanguvw.xyz/tags/canvas/"/>
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/tags/jacascript/"/>
    
      <category term="Css" scheme="http://fanguvw.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现文字跑马灯</title>
    <link href="http://fanguvw.xyz/2018/09/17/%E8%B7%91%E9%A9%AC%E7%81%AF/"/>
    <id>http://fanguvw.xyz/2018/09/17/跑马灯/</id>
    <published>2018-09-17T13:26:12.000Z</published>
    <updated>2018-10-02T13:54:32.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跑马灯思想"><a href="#跑马灯思想" class="headerlink" title="跑马灯思想"></a>跑马灯思想</h2><pre><code>所谓的跑马灯即类似于循环播放的通知告示等等效果。主要利用元素嵌套产生的横向滚动条来控制循环滚动。</code></pre><p><img src="https://github.com/FangFangZhenZhen/FangFangZhenZhen.github.io/raw/SourceCode/source/images/run.gif" alt="Gif run"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;跑马灯&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #box&#123;</span><br><span class="line">            background: pink;</span><br><span class="line">            border: 1px dashed black;</span><br><span class="line">            width: 608px;</span><br><span class="line">            height: 20px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">        #begin&#123;</span><br><span class="line">            white-space: nowrap;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        #end&#123;</span><br><span class="line">            white-space: nowrap;</span><br><span class="line">        &#125;</span><br><span class="line">       #movebox&#123;</span><br><span class="line">           overflow: hidden;</span><br><span class="line">       &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;box&quot;&gt; </span><br><span class="line">        &lt;div id=&quot;movebox&quot;&gt;</span><br><span class="line">                &lt;div id=&quot;begin&quot;&gt; </span><br><span class="line">                        &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div id=&quot;end&quot;&gt; </span><br><span class="line">                    &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">       </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var movebox=document.getElementById(&apos;movebox&apos;);</span><br><span class="line">    var begin=document.getElementById(&apos;begin&apos;);</span><br><span class="line">    var beginWidth=window.getComputedStyle(begin,null).width; //获取元素宽度 自带单位（px）</span><br><span class="line">    // console.log(beginWidth); //string类型 </span><br><span class="line">    var beginw=beginWidth.replace(/px/,&quot;&quot;); //去除px单位</span><br><span class="line">    // console.log(beginw); </span><br><span class="line">    var timer=window.setInterval(function()&#123;</span><br><span class="line">        var curLeft=movebox.scrollLeft; //获取当前加之前的scrollleft值</span><br><span class="line">        movebox.scrollLeft=curLeft+1;  //每隔10毫秒就使文字盒子水平滚动条在当前值上加1</span><br><span class="line">        var newLeft=movebox.scrollLeft; //获取当前加之后的left值</span><br><span class="line">console.log(newLeft); </span><br><span class="line">        // 当scrollLeft值大于等于第一个div宽度时重置位置</span><br><span class="line">        if(newLeft&gt;=beginw)&#123;   </span><br><span class="line">            movebox.scrollLeft=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,10)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;跑马灯思想&quot;&gt;&lt;a href=&quot;#跑马灯思想&quot; class=&quot;headerlink&quot; title=&quot;跑马灯思想&quot;&gt;&lt;/a&gt;跑马灯思想&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;所谓的跑马灯即类似于循环播放的通知告示等等效果。
主要利用元素嵌套产生的横向滚动条来控制循环滚动。

      
    
    </summary>
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/categories/jacascript/"/>
    
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/tags/jacascript/"/>
    
  </entry>
  
  <entry>
    <title>贪吃蛇了解一下</title>
    <link href="http://fanguvw.xyz/2018/09/15/%E8%B4%AA%E5%90%83%E8%9B%87/"/>
    <id>http://fanguvw.xyz/2018/09/15/贪吃蛇/</id>
    <published>2018-09-15T11:24:59.000Z</published>
    <updated>2018-09-17T13:28:04.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用Canvas与JavaScript实现贪吃蛇"><a href="#利用Canvas与JavaScript实现贪吃蛇" class="headerlink" title="利用Canvas与JavaScript实现贪吃蛇"></a>利用Canvas与JavaScript实现贪吃蛇</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用Canvas与JavaScript实现贪吃蛇&quot;&gt;&lt;a href=&quot;#利用Canvas与JavaScript实现贪吃蛇&quot; class=&quot;headerlink&quot; title=&quot;利用Canvas与JavaScript实现贪吃蛇&quot;&gt;&lt;/a&gt;利用Canvas与JavaS
      
    
    </summary>
    
      <category term="Canvas" scheme="http://fanguvw.xyz/categories/canvas/"/>
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/categories/canvas/jacascript/"/>
    
    
      <category term="Canvas" scheme="http://fanguvw.xyz/tags/canvas/"/>
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/tags/jacascript/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现回到页面顶部</title>
    <link href="http://fanguvw.xyz/2018/09/14/%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8/"/>
    <id>http://fanguvw.xyz/2018/09/14/原生JS实现回到顶部/</id>
    <published>2018-09-14T12:47:53.846Z</published>
    <updated>2018-10-02T13:40:04.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><pre><code>1.右下角按钮回到顶部(点击后按钮消失，随即页面滑动到顶部;页面下拉距离超过一屏幕显示回到顶部按钮，反之按钮消失)2.列表hover时显示随机颜色(利用时间委托机制)3.点击左侧列表，页面滑动到对应模块(通过获取所点击列表的ID值滑动到对应CLASS值相同的模块)</code></pre><p><a href="https://github.com/FangFangZhenZhen/Example/blob/master/toTop.html" target="_blank" rel="noopener">点击查看源代码</a></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="回到顶部按钮"><a href="#回到顶部按钮" class="headerlink" title="回到顶部按钮"></a>回到顶部按钮</h3><pre><code>1.获取当前scrollTop距离（var distance=document.documentElement.scrollTop||document.body.scrollTop）2.总时间(var timer=500;单位：ms)  总共需要运动500ms3.频率( var frequency=10;单位：ms) 每10ms运动一次4.步长(var step=distance/timer*frequency)  每毫秒运动距离*频率=每一次运动所需步长</code></pre><h4 id="回到顶部代码"><a href="#回到顶部代码" class="headerlink" title="回到顶部代码"></a>回到顶部代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var span = document.getElementsByTagName(&apos;span&apos;)[0];</span><br><span class="line">var i = document.getElementsByTagName(&apos;i&apos;)[0];</span><br><span class="line">var timer = 1000; //总时间</span><br><span class="line">var frequency = 5; //频率</span><br><span class="line">window.onscroll = show;</span><br><span class="line">function show() &#123;</span><br><span class="line">    var dis = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">    var windis = window.screen.height; //屏幕分辨率高度</span><br><span class="line">    // console.log(windis); </span><br><span class="line">    //当前滚动条距离大于一个屏幕高度时显示回到顶部按钮</span><br><span class="line">    if (dis &gt;= windis) &#123;</span><br><span class="line"></span><br><span class="line">        span.style.display = &apos;block&apos;;</span><br><span class="line">        i.style.display = &apos;block&apos;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //当前滚动条距离小于一个屏幕高度时隐藏回到顶部按钮</span><br><span class="line">        span.style.display = &apos;none&apos;;</span><br><span class="line">        i.style.display = &apos;none&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">span.addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">    span.style.display = &apos;none&apos;; //单击后虽然设置为隐藏，但是由于滚动条顶部距离大于屏幕高度又触发上一个事件，使其又显示，所以当点击时需要阻止上一个事件发生；</span><br><span class="line">    i.style.display = &apos;none&apos;;</span><br><span class="line">    window.onscroll = null; //点击后阻止前一个DOM 0级事件  二级事件无法用此方法阻止</span><br><span class="line">    e = e || event;</span><br><span class="line">    var disTop = document.documentElement.scrollTop || document.body.scrollTop; //获取运动前滚动条顶部距离</span><br><span class="line">    var step = (disTop / timer) * frequency; //步长</span><br><span class="line">    //定时器：每隔一定频率运动距离</span><br><span class="line">    var intime = window.setInterval(function () &#123;</span><br><span class="line">        var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离</span><br><span class="line">        if (curTop === 0) &#123;</span><br><span class="line"></span><br><span class="line">            window.clearInterval(intime); //当距离为0时清除定时器</span><br><span class="line">            window.onscroll = show;</span><br><span class="line">            return; //中断执行</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curTop -= step; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长</span><br><span class="line">        &#125;</span><br><span class="line">        //每隔frequency时间设置一次滚动条距离</span><br><span class="line">        document.documentElement.scrollTop = curTop;</span><br><span class="line">        document.body.scrollTop = curTop;</span><br><span class="line">    &#125;, frequency);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="列表随机颜色"><a href="#列表随机颜色" class="headerlink" title="列表随机颜色"></a>列表随机颜色</h3><pre><code>1.利用事件委托机制给父级DIV加一个mouseover事件2.mouseover在其子对象li上时触发事件，获取触发事件的目标(var elem = e.target;),对此目标进行操作3.定义一个数组存放十六进制数，用于组成随机十六进制颜色，生成6个随机数(0-15)作为数组下标，将对应值存入一个空数组并转为字符串，即为十六进制颜色。</code></pre><h4 id="随机颜色代码"><a href="#随机颜色代码" class="headerlink" title="随机颜色代码"></a>随机颜色代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var items = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">var ul = document.getElementsByTagName(&apos;ul&apos;);</span><br><span class="line">// console.log(ul[0]);</span><br><span class="line">//事件委托：给父元素添加触发事件</span><br><span class="line">ul[0].addEventListener(&apos;mouseover&apos;, function (e) &#123;</span><br><span class="line">    e = e || event;</span><br><span class="line">    var elem = e.target; //获取目标</span><br><span class="line">    elem.style.background = null; // 每一次触发事件都先初始化</span><br><span class="line">    var num = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; //十六进制颜色</span><br><span class="line">    var colorNum = [];</span><br><span class="line">    do &#123;</span><br><span class="line">        var randomNum = Math.floor(Math.random() * 16); //0-15 //随机的0-15之间的一个数字作为十六进制数组下标</span><br><span class="line">        colorNum.push(num[randomNum]);</span><br><span class="line">    &#125; while (colorNum.length &lt; 6); //将获取的6个随机数到空数组</span><br><span class="line">    // console.log(colorNum);</span><br><span class="line">    var colorstr = colorNum.join(&apos;&apos;); //转为字符串</span><br><span class="line">    //   console.log(colorstr);</span><br><span class="line">    elem.style.background = &quot;#&quot; + colorstr; //设置随机颜色</span><br><span class="line">&#125;);</span><br><span class="line">//鼠标离开时清空颜色</span><br><span class="line">ul[0].addEventListener(&apos;mouseout&apos;, function (e) &#123;</span><br><span class="line">    e = e || event;</span><br><span class="line">    var elem = e.target;</span><br><span class="line">    elem.style.background = null;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="滑动模块"><a href="#滑动模块" class="headerlink" title="滑动模块"></a>滑动模块</h3><pre><code>1.与获取随机颜色原理相同，需要利用事件委托，通过给父元素DIV加点击事件获取目标事件2.获取所点击目标的ID值，寻找模块中CLASS值与ID值相同的模块，并获取其距离顶部高度3.需要设置过渡动画效果则与按钮部分相同需要设置运动总时间、总距离、频率等</code></pre><h4 id="滑动模块代码"><a href="#滑动模块代码" class="headerlink" title="滑动模块代码"></a>滑动模块代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ul[0].addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">    e = e || event;</span><br><span class="line">    var liElem = e.target; //利用时间委托获取目标</span><br><span class="line">    var liName = liElem.getAttribute(&apos;id&apos;) //获取目标id值</span><br><span class="line">    var divName = document.getElementsByClassName(liName)[0]; //获取对应名称的DIV模块元素</span><br><span class="line">    var top = divName.offsetTop; //获取对应的滚动条高度</span><br><span class="line">    var timer = 500; //总时间</span><br><span class="line">    var frequencytwo = 3; //频率</span><br><span class="line">    if (top &lt; timer) &#123;</span><br><span class="line">        top += 500;</span><br><span class="line">    &#125;</span><br><span class="line">    var stepgo = (top / timer) * frequencytwo; //步长</span><br><span class="line">    //定时器：每隔一定频率运动距离</span><br><span class="line">    var intn = window.setInterval(function () &#123;</span><br><span class="line">        var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离</span><br><span class="line">        if (curTop === top) &#123;</span><br><span class="line">            window.clearInterval(intn); //当两者相同时清除定时器</span><br><span class="line">            return; //中断执行       </span><br><span class="line">        &#125;</span><br><span class="line">        if (curTop &gt; top) &#123;</span><br><span class="line">            curTop -= stepgo; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长    </span><br><span class="line">        &#125;</span><br><span class="line">        if (curTop &lt; top) &#123;</span><br><span class="line">            curTop += stepgo;</span><br><span class="line">        &#125;</span><br><span class="line">        //每隔frequency时间设置一次滚动条距离</span><br><span class="line">        document.documentElement.scrollTop = curTop;</span><br><span class="line">        document.body.scrollTop = curTop;</span><br><span class="line"></span><br><span class="line">    &#125;, frequencytwo);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code> 本人才疏学浅，暂时只能展示所知显浅部分，有误或可改进之处请留言告知 ◕‿-</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.右下角按钮回到顶部(点击后按钮消失，随即页面滑动到顶部;页面下拉距离超过一屏幕显示回到顶部按钮，反之按钮
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/categories/jacascript/"/>
    
    
      <category term="JavaScript" scheme="http://fanguvw.xyz/tags/jacascript/"/>
    
  </entry>
  
</feed>
