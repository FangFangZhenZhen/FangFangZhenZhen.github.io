<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端开发优化常用办法汇总]]></title>
    <url>%2F2018%2F06%2F01%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BC%98%E5%8C%96%E5%B8%B8%E7%94%A8%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[减少HTTP请求次数或者减小请求数据的大小 页面中每发送一次HTTP请求,都需要完成请求+响应这个完整的HTTP事务,会消耗一些时间,也可能会导致HTTP链接通道的堵塞,为了提高页面加载速度和运行的性能,我们应该减少HTTP请求次数和减小请求数据的大小(请求内容越大,消耗的时间越久) 采用雪碧图(CSS Sprite/CSS图片精灵)技术,把一些小图合并在一张大图上,使用的时候通过背景图定位,定位到具体的某一张小图上 123456789.pubBg&#123; background:url('../images/sprite.png') no-repeat; background-size:x y;/*和原图大小保持一致*/&#125;.box&#123; background-position:x y;/*通过背景定位,定位到具体的位置,展示不同的图片即可*/&#125;...&lt;div class="pubBg box"&gt;&lt;/div&gt; 真实项目中,我们最好把CSS或者JS文件进行合并压缩；尤其是在移动端开发的时候，如果CSS与JS内容不是很多，我们可以采取内嵌式，以此减少HTTP请求的次数，加快页面加载速度； CSS合并成一个，JS最好也合并成一个 首先通过一些工具，(例如：webpack，gulp)把合并后的css与js压缩成xxx.min.js，减小文件的大小 服务器端开启资源文件的GZIP压缩 … 通过一些自动化工具完成CSS以及JS的合并压缩，或者再完成LESS转CSS，ES6转ES5等操作，我们把这种自动化构建模式，称之为前端“工程化”开发 采用图片懒加载技术，在页面开始加载的时候，不请求真实的图片地址，而是用默认图占位，当页面加载完成后，再根据相关的条件依次加载真实图片（减少页面首次加载HTTP请求的次数） 真实项目中，我们开始图片都不加载，页面首次加载完成，先把第一屏中可以看见的图片进行加载，随着页面滚动，再把下面区域中能够呈现出来的图片进行加载 根据图片懒加载技术，我们还可以扩充出数据的懒加载 开始加载页面的时候，我们只把首屏或者前两屏的数据从服务器端开始请求（有些网站首屏数据是后台渲染好，整体返回给客户端呈现的） 当页面下拉，滚动到哪个区域，再把这个区域需要的数据进行请求（请求回来做数据绑定以及图片延迟加载等） 分页展示技术采用的也是数据的懒加载思想实现:如果我们请求获取的数据过多，我们最好分批请求，开始只请求第一页数据，当用户点击第二页（微博是下拉到一定距离再请求第二页数据）的时候再请求第二页数据… 如果当前页面中出现了AUDIO或者VIDEO标签,我们最好设置他们的preload=none:页面加载的时候，音频资源不进行加载，播放的时候再开始加载（减少页面首次加载HTTP请求的次数） preload=auto: 页面首次加载的时候就把音频资源进行加载了 preload=metadata: 页面首次加载的时候只把头部信息进行加载 在客户端和服务器端进行数据通信的时候，我们尽量采用JSON格式进行数据传输 【优势】 JSON格式的数据，能够清晰明了的展示出数据的结构，而且也很方便我们获取和操作 相对于很早以前的XML格式传输，JSON格式的数据更加轻量化 客户端和服务器端都支持JSON格式数据的处理，处理起来非常方便 真实项目中，并不是所有的数据都要基于JSON，我们尽可能这样做，但是对于某些特殊要求（例如：文件流的传输或者文档传输），使用JSON就不合适了 关于编写代码时候的一些优化技巧 除了减少HTTP请求次数和数据大小可以优化性能，我们还可以在编写代码的时候进行一些优化，让页面的性能有所提升（有些不好的代码编写习惯，会导致页面性能消耗太大，例如：内存泄露） 在编写代码的时候，尽量减少对DOM的操作(VUE与REACT框架在这方面处理非常不错) 在JS中操作DOM是一个非常消耗性能的事情，但是我们又不可避免的操作DOM，我们只能尽量减少对于它的操作 【操作DOM弊端】 DOM存在映射机制，（JS中的DOM元素对象和页面中的DOM结构是存在映射机制的，一改则都改），这种映射机制，是浏览器按照W3C标准完成对JS语言的构建和DOM的构建（其实就是构建了一个监听机制），操作DOM是同时要修改俩个地方，相对于一些其他的JS编程来说是较消耗性能的 页面中的DOM结构改变或者样式改变，会触发浏览器的回流（浏览器会把DOM结构重新进行计算，这个操作很耗性能）和重绘（把一个元素的样式重新渲染） … 编写代码的时候，更多地使用异步编程 同步编程会导致：上面的任务未完成，下面的任务也无法完成，我们开发的时候，可以把某一个区域模块都设置未异步编程，这样只要模块之间没有必然的先后顺序，都可以独立加载，不会受到上面模块的堵塞影响（用的不多） 尤其是AJAX数据请求，我们一般都要使用异步编程，最好是基于promise设计模式进行管理（项目中经常使用fetch、axios等插件进行AJAX请求处理，因为这些插件都是基于promise设计模式对AJAX进行封装处理） 在真实项目中，我们尽可能避免一次性循环过多数据（因为循环操作是同步编程），尤其是要避免while导致的死循环操作 CSS选择器优化 尽量减少标签选择器的使用 尽可能少的使用ID选择器，多使用样式类选择器（通用性强） 减少选择器前面的前缀，例如：.headBox .nav .left a{...}(选择器是从右向左查找的) 避免使用CSS表达式]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP等传输协议理解]]></title>
    <url>%2F2018%2F04%2F27%2FHTTP%E7%AD%89%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[URL、URI、URN URL:统一资源标识符 URI:统一资源路径地址 URN:统一资源名称 URI=URL+URN 一个完整的URL包含很多部分http://fanguvw.xyz/index.html?name=fang&amp;age=22#good 传输协议传输协议是用来完成客户端和服务器端的数据(内容)传输,类似于快递小哥,负责把客户和商家的物品来回传送 客户端不仅可以向服务器发送请求,而且还可以把一些内容传送给服务器 服务器也可以把内容返回给客户端 客户端和服务器端传输的内容总称为HTTP报文,这些报文信息都是基于传输协议完成传输的,客户端传递给服务器叫做请求(request),服务器返回给客户端叫做响应(response),request+response两个阶段统称为一个HTTP事务(事务:一件完整的事情) HTTP事务 当客户端向服务器端发送请求,此时客户端和服务器端会建立一个传输通道(连接通道),传输协议就是基于这个通道把信息进行传输 当服务器端接受到请求信息,把内容返回给客户端后,传输通道会自动销毁关闭传输协议分类 HTTP：超文本传输协议(客户端和服务器端传输的内容除了文本以外,还可以传输图片、音频等文件[二进制编码/base64码],以及传输xml格式的数据等),是目前应用最广泛的传输协议 HTTPS：http+ssl,它比http更加安全,因为数据内容的传输通道时经过ssl加密的(它需要再服务器端进行特殊的处理),所以涉及资金类的网址一般都时https协议 FTP：资源文件传输协议,一般用于客户端把资源文件(不是代码)上传到服务器,或者从服务器端下载一些资源文件(一般传输的内容会比http这类协议传输内容多) ……HTTP报文 起始行 请求起始行 响应起始行 首部(头) 请求头：内置请求头、自定义请求头 响应头：内置响应头、自定义响应头 通用头：请求和响应都有的 主体 请求主体 响应主体 请求XXX都是客户端设置的信息,服务器端获取这些信息 响应XXX都是服务器端设置的信息,客户端用来接受这些信息 在谷歌浏览器控制台Network选项中,我们可以看见当前客户端和服务器端交互的全部信息总结 客户端传递给服务器端数据 URL问号传递参数 设置请求头 设置请求主体 服务器端返回给客户端内容 设置响应头(例如服务器时间) 设置响应主体 ……]]></content>
      <categories>
        <category>传输协议</category>
      </categories>
      <tags>
        <tag>传输协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端和服务器端交互模型]]></title>
    <url>%2F2018%2F04%2F14%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[当我们在浏览器中输入一个地址，到最后看到页面，中间都经历了哪些事情？假设我们访问的是https://fanguvw.xyz 这个地址，当我们摁下Enter键，我们可以看到博客首页： 博客首页并没有在我们客户端本地，我们输入地址后才请求过来 输入不同的域名可以看到不同的页面 有的网址是https，有的是http(或者还有ftp) 需要客户端联网才能完成这些事情 那期间究竟经历了哪些事呢？以下进行简单概述 [Request请求阶段] 首先根据客户端输入的域名，到DNS服务器上进行反解析(通过域名找到对应服务器的外网IP) 通过找到的外网IP，找到对应的服务器 通过在地址中输入的端口号(没输入是因为不同协议有自己默认的端口号)找到服务器上发布的对应项目[Response响应阶段] 服务器获取到请求的资源文件的地址例如:/stu/index.html,把资源文件中的源代码找到 服务器会把找到的源代码返回给客户端(通过HTTP等传输协议返回)[浏览器自主渲染] 客户端接收到源代码后交给浏览器的内核(渲染引擎)进行渲染,最后又浏览器绘制出对应的页面]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git总结]]></title>
    <url>%2F2018%2F04%2F10%2FGit%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概念理解 index暂存(又名staging area–暂存区) 暂存区是可以设置哪些变更要提交到版本库，哪些先不提交。临时存放的地方（staging area）。 work area–工作区 我们工作的区域空间 local repository–本地仓库 就是我们自己工作的电脑上保存版本数据的地方 remote repository–远程仓库 我们用Git进行操作，为了防止数据在自己电脑上丢失，比如错误删除，病毒攻击等原因造成了数据丢失，我们需要备份到远程的服务器上，这个服务器可以理解为远程仓库。 生成SSH Key 在用户目录下查看是否有.ssh目录若有则查看目录下是否有id_rsa（密钥）和id_rsa.pub（公钥）若有则不必再次生成直接使用 创建SSH Key：ssh-keygen -t rsa -C “851580041@qq.com“ 登录到代码托管平台(如github)打开账户设置中的SSHKey页面粘贴公钥 可添加多个key(只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了)使用流程 [workspace] -&gt; add -&gt; [local cache] -&gt; commit -&gt;[local repository] -&gt; push -&gt;[remote git repository]-&gt; clone -&gt; [git repository] checkout -&gt; [workspace]常用操作本地初始化关联远程仓库12345678910git config --global user.name &apos;nick&apos;git config --global user.email &apos;851580041@qq.com&apos;git init gitlearn # 初始化项目git status # 查看状态git add 1.txt # 添加修改到本地缓存git add -A # 添加所有到本地缓存git commit -am &apos;1.txt&apos; # 添加提交到本地仓库git remote add origin https://github.com/csy512889371/gitlearn.git #添加远程仓库git remote #查看远程git push origin master -u 克隆及更新12git clone https://github.com/example/example.git #克隆项目git pull # 拉取代码 分支管理查看切换合并12345678git branch [-v] # 查看当前分支git branch &lt;branch name&gt;# 基于当前分支新建分支git branch &lt;branch name&gt; &lt;commit id&gt;# 基于提交新建分支git checkout &lt;branch name&gt; #切换分支git merge &lt;merge target&gt; #用于合并指定分支到当前分支# 解决冲突，如果因冲突导致自动合并失败，此时status为mergeing状态# 需要手动修改后重新提交(commit) 创建删除分支12345678910git branchgit branch -agit branch dev #创建分支devgit checkout dev #切换到dev分支git branch -d dev #删除分支git branch -D 强行删除未合并的分支git push origin dev -u #将分支提交到远程服务器git branch -avgit branch -avv 提交代码冲突1234git pull# 本地合并git commit -am &apos;重新提交&apos;git push #提交到服务器 如果本地项目和远程都有项目且未做关联12git branch --set-upstream-to=origin/master mastergit pull --allow-unrelated-histories 合并时强制禁用Fast forward123456789101112首先，仍然创建并切换dev分支：git checkout -b dev修改readme.md文件，并提交一个新的commit：git add readme.mdgit commit -m &quot;add merge&quot;现在，我们切换回master：git checkout master准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：git merge --no-ff -m &quot;merge with no-ff&quot; devgit merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。git merge 则不会显示 feature，只保留单条分支记录。 标签1234567git tag v1.0 #创建标签git tag #标签状态git push origin v1.0 -u #提交标签到远程仓库git tag -d v1.0 #删除标签git branch v1.0_dev v1.0 #基于标签创建分支git log #查看日志 标签管理（标签也是版本库的一个快照）1234567891011121314151617命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。还可以通过-s用私钥签名一个标签：git tag -s v0.5 -m &quot;signed version 0.2 released&quot; fec145agit tag可以查看所有标签。用命令git show &lt;tagname&gt;可以查看某个标签的详细信息。如果标签打错了，也可以删除：git tag -d v0.1因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;：git push origin v1.0或者，一次性推送全部尚未推送到远程的本地标签：git push origin --tags如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：git tag -d v0.9然后，从远程删除。删除命令也是push，但是格式如下：git push origin :refs/tags/v0.9 项目目前状态1$git status//查看当前git版本库的状态 退回某个版本步骤 git log查看所有历史版本 获取某个历史版本的id git reset –hard id值 将修改提交到服务器（git push -f -u origin master）存储当前工作状态 git stash （储藏当前状态之后，就能切换到别的分支） git stash list (查看储藏状态的列表) git stash apply 储藏的名字 （回到原来的分支之后，如何恢复到之前那种混乱的工作状态）实际开发中版本控制原则 master与daily-test为只读分支 所有合并原则上不可逆 日常或紧急分支上线后就不可再使用（建议删除） master与线上完全同步 daily-test版本必须大于等于master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用默认端口号]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B8%B8%E7%94%A8%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[代理服务器常用端口计算机端口号范围1~65535，端口不能重复 HTTP协议代理服务器常用端口号：80/8080/3128/8081/9080 SOCKS代理协议服务器常用端口号：1080 FTP（文件传输）协议代理服务器常用端口号：21 Telnet（远程登录）协议代理服务器常用端口：23常用端口说明 端口：21 服务：FTP 说明：FTP服务器所开放的端口，用于上传、下载。最常见的攻击者用于寻找打开anonymous的FTP服务器的方法。这些服务器带有可读写的目录。木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口。 端口：22 服务：SSH 说明：PcAnywhere建立的TCP和这一端口的连接可能是为了寻找ssh。这一服务有许多弱点，如果配置成特定的模式，许多使用RSAREF库的版本就会有不少的漏洞存在。 端口：23 服务：Telnet 说明：远程登录，入侵者在搜索远程登录UNIX的服务。大多数情况下扫描这一端口是为了找到机器运行的操作系统。还有使用其他技术，入侵者也会找到密码。木马Tiny Telnet Server就开放这个端口。 端口：25 服务：SMTP 说明：SMTP服务器所开放的端口，用于发送邮件。入侵者寻找SMTP服务器是为了传递他们的SPAM。入侵者的帐户被关闭，他们需要连接到高带宽的E-MAIL服务器上，将简单的信息传递到不同的地址。木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口。 端口：80 服务：HTTP 说明：用于网页浏览。木马Executor开放此端口。 端口：443 服务：Https 说明：网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。 端口：1080 服务：SOCKS 说明：这一协议以通道方式穿过防火墙，允许防火墙后面的人通过一个IP地址访问INTERNET。理论上它应该只允许内部的通信向外到达INTERNET。但是由于错误的配置，它会允许位于防火墙外部的攻击穿过防火墙。WinGate常会发生这种错误，在加入IRC聊天室时常会看到这种情况。 端口：3128 服务：squid 说明：这是squid HTTP代理服务器的默认端口。攻击者扫描这个端口是为了搜寻一个代理服务器而匿名访问Internet。也会看到搜索其他代理服务器的端口8000、8001、8080、8888。扫描这个端口的另一个原因是用户正在进入聊天室。其他用户也会检验这个端口以确定用户的机器是否支持代理。 端口：443 服务：Https 说明：网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。 常见端口地点 HTTP服务器，默认的端口号为80/tcp（木马Executor开放此端口）； HTTPS（securely transferring web pages）服务器，默认的端口号为443/tcp 443/udp； Telnet（不安全的文本传送），默认端口号为23/tcp（木马Tiny Telnet Server所开放的端口）； FTP，默认的端口号为21/tcp（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）； TFTP（Trivial File Transfer Protocol ），默认的端口号为69/udp； SSH（安全登录）、SCP（文件传输）、端口重定向，默认的端口号为22/tcp； SMTP Simple Mail Transfer Protocol (E-mail)，默认的端口号为25/tcp（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）； POP3 Post Office Protocol (E-mail) ，默认的端口号为110/tcp； WebLogic，默认的端口号为7001； Webshpere应用程序，默认的端口号为9080； webshpere管理工具，默认的端口号为9090； JBOSS，默认的端口号为8080； TOMCAT，默认的端口号为8080； WIN2003远程登陆，默认的端口号为3389； Symantec AV/Filter for MSE ,默认端口号为 8081； Oracle 数据库，默认的端口号为1521； ORACLE EMCTL，默认的端口号为1158； Oracle XDB（ XML 数据库），默认的端口号为8080； Oracle XDB FTP服务，默认的端口号为2100； MS SQL*SERVER数据库server，默认的端口号为1433/tcp 1433/udp； MS SQL*SERVER数据库monitor，默认的端口号为1434/tcp 1434/udp； QQ，默认的端口号为1080/udp]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS实现局域网联调]]></title>
    <url>%2F2018%2F03%2F15%2FIIS%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E8%B0%83%2F</url>
    <content type="text"><![CDATA[建立局域网络1.手机打开热点 2.使你的笔记本连接至手机热点 3.这时手机与笔记本就已经处于同一个局域网内了 基于IIS建立本地项目服务1.打开控制面板 2.点击程序 3.点击启用或关闭Windows功能 4.选中Internet Information Services(IIS)--不必全选默认方块状态就可以了 5.确定后会进行功能应用 IIS管理器基础设置1.本地搜索并打开IIS管理器 2.在右侧本地服务的网站目录上右键添加网站 3.网站名称随意,物理路径选择你的本地项目地址 4.IP地址为手机热点局域网地址(IP查看方式:运行CMD打开命令行-&gt;输入ipconfig-&gt;复制IPv4地址) 5.端口号范围为1~65535(http默认80,https默认443) 6.主机名为域名,可不填 7.启动服务后即可在PC端与手机端输入ip地址与端口号同时浏览网站进行调试 基本流程图 实现效果 PC端 手机端]]></content>
      <categories>
        <category>IIS</category>
      </categories>
      <tags>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Call_Apply_Bind三者区别]]></title>
    <url>%2F2018%2F03%2F10%2FCall-Apply-Bind%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[非严格模式下123456789101112131415161718// var obj = &#123;// &apos;name&apos;: &apos;fang&apos;,// &apos;sex&apos;: &apos;man&apos;// &#125;;// // console.log(obj[&apos;name&apos;],obj.sex); 获取对象属性值// var fn = function (num1, num2) &#123;// console.log(num1 + num2);// console.log(this);// &#125;// fn.call();//输出： NaN window对象 非严格模式下未指定this则默认指向window// fn.call(undefined); //输出： NaN window对象// fn.call(null); //输出： NaN window对象// fn(100,200); //输出 300 window对象 （fn为window调用）// fn.call(obj, 100, 200); //改变this指向，并传参// fn.apply(obj, [100, 200]); //IE6~8下不兼容 改变this指向，并以数组形式传参 与call只是传参形式不同 在严格与非严格模式下this指向输出相同// var tempFn = fn.bind(obj, 100, 200); //无输出 只是提前修改了this指向并传参 但并未执行 简称预处理！！！可将返回值预先传给变量 需要时再调用执行// tempFn(); 严格模式下123456789101112131415 // &apos;use strict&apos;// var obj = &#123;// &apos;name&apos;: &apos;fang&apos;,// &apos;sex&apos;: &apos;man&apos;// &#125;;// var fn = function (num1, num2) &#123;// console.log(num1 + num2);// console.log(this);// &#125;// fn.call(); //输出 NaN undefined// fn.call(undefined);//输出 NaN undefined// fn.call(null);//输出 NaN null// fn.call(100,200); //输出 NaN 100 this指向100 只传了一个参数所以为200+num2 为 NaN// 严格模式下call指向谁就输出谁 未输入则输出undefined// call与apply使用情况由项目决定 获取数组最大值与最小值思想思想一排序法（arr.sort）1234567// var arr = [12, 25, 1, 22, 8, 6, 88, 7, 9, 44];// arr.sort(function (a, b) &#123;// return a - b;// &#125;); //小到大排序// var max = arr[arr.length - 1];// var min = arr[0];// console.log(min, max); 思想二eval() 字符串拼接实现 Math.max() Math.min()1234567891011// var arr = [12, 25, 1, 22, 8, 6, 88, 7, 9, 44];// var max= Math.max(arr); //输出NaN 此方法需要一个一个写入值// var max=Math.max(2,5,11,1,4); //输出：11// 所以需要将arr转为一个一个数传入此方法// var str = arr.toString(); // &apos;12, 25, 1, 22, 8, 6, 88, 7, 9, 44&apos;// // eval:此方法将会将字符串作为JS语句执行 可用于计算表达式类型字符串的值eval(&quot;1+2+4&quot;)===7// // var evalstr= eval(str); //输出44 失败 原因:当括号括号函数中传入多个需要执行的值,将只执行最后一个 并会改变this指向// // 尝试字符串拼接的思想 -&gt;成功// var max = eval(&apos;Math.max(&apos; + str + &apos;)&apos;); //eval(&apos;Math.max(12, 25, 1, 22, 8, 6, 88, 7, 9, 44)&apos;);// var min = eval(&apos;Math.min(&apos; + str + &apos;)&apos;); //eval(&apos;Math.min(12, 25, 1, 22, 8, 6, 88, 7, 9, 44)&apos;);// console.log(min, max); 思想三假设法 假设一个为最大值或最小值 循环比较 替换值1234567// var arr = [12, 25, 1, 22, 8, 6, 88, 7, 9, 44]; // var min=arr[0],max=arr[0]; // for(var i=1;i&lt;arr.length;i++)&#123; // arr[i]&lt;min?min=arr[i]:null; // arr[i]&gt;max?max=arr[i]:null; // &#125; // console.log(min,max); 思想四apply(null,arr) Math.max() Math.min();12345// var arr = [12, 25, 1, 22, 8, 6, 88, 7, 9, 44]; // var max = Math.max.apply(null, arr); // var min = Math.min.apply(null, arr); // console.log(max); // console.log(min);]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置模块常用方法]]></title>
    <url>%2F2018%2F02%2F22%2F%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SERVER1234567891011121314151617181920212223242526272829303132333435 // 导入常用的三个内置模块const http = require(&apos;http&apos;);const fs = require(&apos;fs&apos;);const url = require(&apos;url&apos;); //-&gt; URL模块中提供一个方法 url.parse() 用于解析url地址// 1.HTTP//-&gt;http.createServer:创建一个服务// -&gt;server.listen:为这个服务监听一个端口888 端口范围：0~65535var server = http.createServer(function (request, response) &#123; // 当客户端向当前服务（端口为888）发送一个请求，并且当前服务已经成功接收到这个请求后执行这个回调函数 // 发送请求方式： 1.http://localhost:端口号/ 2. http://本机IP地址：端口号/ // request（请求）:存放的是所有客户端的请求信息，包含客户端通过问号传参的方式传递的数据 // response（响应）：提供了向客户端返回内容与数据的方法 // console.log(request.url); // request.url:存放的是客户端请求的文件资源的目录和名称已经传递给服务器的数据 // 客户端请求的完整地址为：http://localhost:888/index.html?name=fang&amp;age=22 通过request.url获取到的为 /index.html?name=fang&amp;age=22 var urlObj = url.parse(request.url, true); var pathname = urlObj.pathname; //请求资源路径+名称 console.log(pathname); var query = urlObj.query; //客户端传递来的数据（键值对形式） if (pathname === &apos;/server1.html&apos;) &#123; // 根据请求的URL地址（主要是地址中的pathname）获取到对应资源的源代码 //fs.readFileSync([path+name],[encode]):同步读取指定文件中的内容（同步读取：文件内容读取完成才执行后续操作） var con = fs.readFileSync(&apos;./server1.html&apos;, &apos;utf8&apos;); response.write(con); //向客户端返回内容 response.end(); //告诉服务器响应结束（必须写） &#125;&#125;);server.listen(666, function () &#123; // 当服务创建成功，且端口号也监听成功后执行 console.log(&apos;server iscreate success! listening on 666 port! &apos;);&#125;); URL12345678910111213141516171819202122232425262728 const url = require(&apos;url&apos;);var u = &apos;http://localhost:888/index.html?name=fang&amp;age=22#fang&apos;;// console.log(url.parse(u));//解析url地址 输出一个对象/* Url &#123; protocol: &apos;http:&apos;, //传输协议 slashes: true, auth: null, host: &apos;localhost:888&apos;, //域名+端口号 port: &apos;888&apos;, //端口号 hostname: &apos;localhost&apos;, //域名 hash: #fang, //hash值 search: &apos;?name=fang&amp;age=22&apos;, //问号加传递来的数据 query: &apos;name=fang&amp;age=22&apos;, //传递来的数据 pathname: &apos;/index.html&apos;, //请求文件的路径及名称 path: &apos;/index.html?name=fang&amp;age=22&apos;, //路径+名称+数据 href: &apos;http://localhost:888/index.html?name=fang&amp;age=22&apos; //完整请求地址 &#125; */console.log(url.parse(u, true));//解析url地址 输出一个对象 加true后query部分变成键值对形式 所以平时这样使用更易操作/*Url &#123; 。。。 query: &#123; name: &apos;fang&apos;, age: &apos;22&apos; &#125;, 。。。&#125;*/ QUERYSTRING123456789101112131415161718192021222324252627282930313233343536373839 const querystring = require(&apos;querystring&apos;);var data = &#123; protocol: &apos;https:&apos;, slashes: true, auth: null, host: &apos;www.ibm.com:443&apos;, port: &apos;443&apos;, hostname: &apos;www.ibm.com&apos;, hash: &apos;#name&apos;, search: &apos;?name=fang&amp;sex=man&apos;, query: &apos;name=fang&amp;sex=man&apos;, pathname: &apos;/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html&apos;, path: &apos;/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html?name=fang&amp;sex=man&apos;, href: &apos;https://www.ibm.com:443/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html?name=fang&amp;sex=man#name&apos;&#125;;var q = querystring.stringify(data); //将url对象转为url字符串拼接格式 输出内容需要进行地址解码/* protocol=https%3A&amp;slashes=true&amp;auth=&amp;host=www.ibm.com%3A443&amp;port=443&amp;hostname=www.ibm.com&amp;hash=%23name&amp;search=%3Fname%3Dfang%26sex%3Dman&amp;query=name%3Dfang%26sex%3Dman&amp;pathname=%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-use-javascript-closures-efficiently%2Findex.html&amp;path=%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-use-javascript-closures-efficiently%2Findex.html%3Fname%3Dfang%26sex%3Dman&amp;href=https%3A%2F%2Fwww.ibm.com%3A443%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-use-javascript-closures-efficiently%2Findex.html%3Fname%3Dfang%26sex%3Dman%23name */// q = querystring.unescape(q); //对url字符串地址进行解码 编码为：querystring.escape();/*protocol=https:&amp;slashes=true&amp;auth=&amp;host=www.ibm.com:443&amp;port=443&amp;hostname=www.ibm.com&amp;hash=#name&amp;search=?name=fang&amp;sex=man&amp;query=name=fang&amp;sex=man&amp;pathname=/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html&amp;path=/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html?name=fang&amp;sex=man&amp;href=https://www.ibm.com:443/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html?name=fang&amp;sex=man#name*/q = querystring.parse(q); //将完整地址转为对象格式/** &#123; protocol: &apos;https:&apos;, slashes: &apos;true&apos;, auth: &apos;&apos;, host: &apos;www.ibm.com:443&apos;, port: &apos;443&apos;, hostname: &apos;www.ibm.com&apos;, hash: &apos;#name&apos;, search: &apos;?name=fang&amp;sex=man&apos;, query: &apos;name=fang&amp;sex=man&apos;, pathname: &apos;/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html&apos;, path: &apos;/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html?name=fang&amp;sex=man&apos;, href: &apos;https://www.ibm.com:443/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html?name=fang&amp;sex=man#name&apos; &#125; */console.log(q); APPENDFILE12345 var fs = require(&apos;fs&apos;);var data = `this is append data from `+__filename;fs.appendFile(&apos;./test1/new1.js&apos;, data, (err) =&gt; &#123; if (err) throw err;&#125;); RENAME123456789101112 const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);files = fs.readdirSync(&apos;./test1&apos;);// console.log(files);for (var i = 0; i &lt;files.length; i++) &#123; var oldpath = path.join(__dirname, &apos;test1&apos;, files[i]); var newpath = path.join(__dirname, &apos;test1&apos;, files[i].replace(/test/, &apos;new&apos;)); console.log(newpath); fs.rename(oldpath, newpath, (err) =&gt; &#123; if (err) throw err; &#125;);&#125; CHMODSYNC123456789101112 const fs = require(&apos;fs&apos;);fs.chmodSync(&apos;./test1/new1.js&apos;, 0o444);// Number Description// 7 read, write, and execute// 6 read and write// 5 read and execute// 4 read only// 3 write and execute// 2 write only// 1 execute only// 0 no permission ACCESS1234567891011121314151617181920212223242526272829303132 const fs = require(&apos;fs&apos;);// fs.access(&apos;./test1/new1.js&apos;,fs.constants.F_OK, (err) =&gt; &#123;// console.log(`$&#123;&apos;./test1/new1.js&apos;&#125;$&#123;err ? &apos;不存在&apos; :&apos;存在&apos;&#125;`);// &#125;);// fs.access(&apos;./test1/new1.js&apos;, fs.constants.W_OK, (err) =&gt; &#123;// console.log(`$&#123;&apos;./test1/new1.js&apos;&#125;$&#123;err?&apos;不可写&apos;:&apos;可写&apos;&#125;`);// &#125;);// fs.access(&apos;./test1/new1.js&apos;, fs.constants.R_OK, (err) =&gt; &#123;// console.log(`$&#123;&apos;./test1/new1.js&apos;&#125;$&#123;err?&apos;不可读&apos;:&apos;可读&apos;&#125;`);// &#125;);// fs.access(&apos;./test1/new1.js&apos;, fs.constants.E_OK, (err) =&gt; &#123;// console.log(`$&#123;&apos;./test1/new1.js&apos;&#125;$&#123;err?&apos;不可执行&apos;:&apos;可执行&apos;&#125;`);// &#125;);fs.access(&apos;./test1/new1.js&apos;, fs.constants.F_OK, (err) =&gt; &#123; err ? console.log(&apos;文件不存在&apos;) : fs.access(&apos;./test1/new1.js&apos;, fs.constants.W_OK, (err) =&gt; &#123; err ? fs.chmodSync(&apos;./test1/new1.js&apos;, 0o765, (err) =&gt; &#123; if (err) throw err; // 备注部分执行不到 // fs.appendFile(&apos;./test1/new1.js&apos;, &apos; 源文件不可写，以修改权限，写入成功···&apos;, (err) =&gt; &#123; // if (err) throw err; // &#125;); &#125;) : fs.appendFile(&apos;./test1/new1.js&apos;, &apos; 源文件可写，写入成功···&apos;, (err) =&gt; &#123; if (err) throw err; &#125;); &#125;)&#125;); CRYPTO1234567 const crypto = require(&apos;crypto&apos;);const secret = &apos;abcdefg&apos;;const hash = crypto.createHmac(&apos;sha256&apos;, secret) .update(&apos;I love cupcakes&apos;) .digest(&apos;hex&apos;);console.log(hash);]]></content>
      <categories>
        <category>Server</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态资源文件请求处理]]></title>
    <url>%2F2018%2F02%2F17%2F%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[导入内置模块123const http = require(&apos;http&apos;),url = require(&apos;url&apos;),fs = require(&apos;fs&apos;); 创建服务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var server1 = http.createServer(function (req, res) &#123; //解析客户端请求地址中的文件目录名称以及传递给当前服务器的数据 var urlObj = url.parse(req.url, true), pathname = urlObj[&quot;pathname&quot;], //请求的路径名称 query = urlObj[&quot;query&quot;]; //传递来数据的键值对形式 //处理静态文件资源的请求（HTML/CCS/JS/...） =&gt; &quot;前端路由&quot; =&gt; （判断不同请求响应不同信息） var reg = /\.(HTML|JS|CSS|JSON|TXT|ICO)/i; if (reg.exec(pathname)) &#123; //获取请求文件的后缀 var suffix = reg.exec(pathname)[1].toUpperCase(); // console.log(suffix); //根据请求文件的后缀名获取到当前文件的MIME类型 浏览器会按照代码的MIME类型进行渲染 // MIME类型：HTML -&gt; &quot;text/html&quot; css-&gt;&quot;text/css&quot; TXT-&gt;&quot;text/palin&quot; 。。。 var suffixMIME = &quot;text/plain&quot;; //设置默认MIME类型 switch (suffix) &#123; case &quot;HTML&quot;: suffixMIME = &quot;text/html&quot;; break; case &quot;CSS&quot;: suffixMIME = &quot;text/css&quot;; break; case &quot;JS&quot;: suffixMIME = &quot;text/javascript&quot;; break; case &quot;JSON&quot;: suffixMIME = &quot;application/json&quot;; break; case &quot;ICO&quot;: suffixMIME = &quot;application/octet-stream&quot;; break; &#125; // if (pathname === &quot;/index.html&quot;) &#123; // var con = fs.readFileSync(&apos;./index.html&apos;, &apos;utf-8&apos;); // res.end(con); // &#125; // if (pathname === &quot;/css/index.css&quot;) &#123; // con = fs.readFileSync(&apos;./css/index.css&apos;, &quot;utf-8&quot;); // res.end(con); // &#125; // if (pathname===&quot;/js/index.js&quot;) &#123; // con = fs.readFileSync(&apos;./js/index.js&apos;, &apos;utf-8&apos;); // res.end(con); // &#125; // 如果请求的资源不存在，不写try catch 会使服务停止运行，当加上后会捕获错误信息，即使请求资源不存在不会报错也不会终止服务 try &#123; //以上三个判断可简写为以下语句 // 按照指定目录读取文件中的内容或者代码（字符串格式） var con = fs.readFileSync(&apos;.&apos; + pathname, &apos;utf-8&apos;); // 重写响应头信息：告诉客户端浏览器返回的是什么MIME类型,并指定返回内容格式为UTF-8编码格式 res.writeHead(200, &#123;&apos;content-type&apos;:suffixMIME+&apos;charset=utf-8&apos;&#125;); // 服务端向客户端返回内容（字符串格式） res.end(con); &#125; catch (e) &#123; res.writeHead(404, &#123; &apos;content-type&apos;: &apos;text/plain;charset=utf-8;&apos; &#125;); res.end(&apos;request file is not found!&apos;); &#125; &#125;&#125;); 为当前服务配置端口并监听123server1.listen(5555, function () &#123; console.log(&quot;server is success,listening on 5555 port!&quot;);&#125;);]]></content>
      <categories>
        <category>Server</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库注册用户功能实现]]></title>
    <url>%2F2017%2F11%2F10%2F%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[数据库注册功能实现分析最近模仿百度云写了一套页面,先简单记录一下注册功能的实现 0.检测数据库中用户名是否已存在并将结果显示到前端（通过AJAX的GET请求,连接到PHP查询用户名页,PHP查询页内容为连接数据库并检索数据库中前端传递来的用户名是否已存在,将结果以JSON字符串对象形式返回到前端） 1.提交HTML表单数据到后台PHP获取 2.PHP获取前端表单内name属性值 3.PHP连接数据库检测用户名是否已存在 4.不存在则向数据库插入新用户信息 效果图如下 注册功能表单JS代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 用户名正则验证var userName = $(&apos;#_san_13&apos;);var form = $(&apos;#_san_7&apos;);var submit = $(&apos;#_san_45&apos;);var userReg = /^[A-Za-z\d_-]&#123;6,32&#125;$/; //用户名正则var userError = $(&apos;#_san_81&apos;); //用户名错误文本// 用户名数据库验证//1.完成用户名称的重复性验证（异步，检查数据库中是否已存在当前用户名）//异步请求数据，因为还要输入下面的数据，不能跳转到php页面去验证userName.on(&quot;blur&quot;, function () &#123; //1.创建XHR对象 创建异步对象 var xhr = null; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); //标准创建 &#125; else &#123; //IE6及以下的创建方式 xhr = new ActiveXObject(&quot;Microsoft.XMLHttp&quot;); &#125; //2.创建请求 var uname = userName.val(); //获取输入框里的值，把用户名传到后端，再查询 var url = &quot;../php/check-name.php?uname=&quot; + uname; xhr.open(&quot;get&quot;, url, true); //查询用户名称，用get方法就行，去数据库查询，看用户名是否已经存在 //查询用get就行，向服务器提交数据时再用post //3.设置回调函数，监听状态 //参数true，异步 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; //判断状态，xhr请求状态为4，表示接收响应数据成功；当status的值是200的时候，表示服务器已经正确的处理请求以及给出响应 var resultStr = xhr.responseText; var resultJson =JSON.parse(resultStr); if (resultJson==&apos;true&apos;) &#123; // userError.text(&quot;用户名可用&quot;); &#125; else &#123; form.removeAttr(&quot;action&quot;); userName.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 userName.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 userError.text(&quot;用户名已存在&quot;); &#125; // console.log(resultJson==&apos;false&apos;); //提示内容 &#125;; &#125;; //4.发送请求 xhr.send(null); //get请求，参数写null&#125;);// 密码正则验证var pwd = $(&apos;#_san_19&apos;);var pwdReg = /^.*(?=.&#123;6,32&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/; //密码正则(6-32位且至少1个大写字母，1个小写字母，1个数字)var pwdError = $(&apos;#_san_57&apos;); //密码错误文本// 确认密码验证var pwdCheck = $(&apos;#_san_25&apos;);var pwdCheckReg = /^.*(?=.&#123;6,32&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/; //密码正则(6-32位且至少1个大写字母，1个小写字母，1个数字)var pwdCheckError = $(&apos;#_san_59&apos;); //确认密码错误文本//判断是否可注册submit.on(&apos;mouseover&apos;, function () &#123; // 满足所有规则时向后台提交数据 if (userReg.test(userName.val()) == true&amp;&amp;pwdReg.test(pwd.val())==true&amp;&amp;pwdCheckReg.test(pwdCheck.val())==true &amp;&amp; (pwdCheck.val() === pwd.val())==true) &#123; form.attr(&quot;action&quot;, &quot;../php/reg.php&quot;); &#125; else &#123; form.removeAttr(&quot;action&quot;); &#125;&#125;); PHP检测数据库用户名代码1234567891011121314151617181920212223242526272829303132333435&lt;?php// 1.连接数据库 $conn = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;baidu&quot;); if (!$conn)&#123; echo &quot;Error: Unable to connect to MySQL.&quot; . PHP_EOL; echo &quot;Debugging errno: &quot; . mysqli_connect_errno() . PHP_EOL; echo &quot;Debugging error: &quot; . mysqli_connect_error() . PHP_EOL; exit; &#125;// 设置编码，防止中文乱码 mysqli_set_charset($conn, &quot;utf8&quot;);// 2.接收前端传过来的uname $uname=$_REQUEST[&quot;uname&quot;];// 3.拼接sql，并查询uname是否存在 $sql=&quot; SELECT uname FROM register WHERE uname=&apos;$uname&apos;&quot;; $result=mysqli_query($conn,$sql);// 4.根据查询的结果输出相应$row=mysqli_fetch_row($result); //抓取一条数据，即当前uname对应的数据 $raw_success =&apos;true&apos;; $raw_fail =&apos;false&apos;; $res_success = json_encode($raw_success); $res_fail = json_encode($raw_fail); if($row==null)&#123; //如果$row为空，即数据库中没有相同的用户名存在 echo $res_success; &#125;else&#123; echo $res_fail; &#125;;?&gt; PHP检测是否可注册代码123456789101112131415161718192021222324252627282930313233&lt;?php// 1.获取请求提交的数据 $uname=$_REQUEST[&quot;uname&quot;]; //uname值就是前端页面中name属性的值 $upwd=$_REQUEST[&quot;upwd&quot;]; //确认密码不用获取，获取一个密码就行// 2.连接到数据库$conn = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;baidu&quot;);if (!$conn)&#123; echo &quot;Error: Unable to connect to MySQL.&quot; . PHP_EOL; echo &quot;Debugging errno: &quot; . mysqli_connect_errno() . PHP_EOL; echo &quot;Debugging error: &quot; . mysqli_connect_error() . PHP_EOL; exit;&#125;// 设置编码，防止中文乱码mysqli_set_charset($conn, &quot;utf8&quot;);// 3.写sql语句并执行$sql=&quot;INSERT INTO register (uname, upwd) VALUES (&apos;$uname&apos;,&apos;$upwd&apos;)&quot;;//字段值 外面用双引号，里面用单引号$result=mysqli_query($conn,$sql);//执行sql语句// 4.根据执行结果给出响应 if($result==true)&#123; //函数返回值 echo &quot;&lt;span style=&quot;font-size:40px;color:red;&quot;&gt;注册成功&lt;/span&gt;&quot;; echo &apos;&lt;a href=&quot;../html/login.html&quot; style=&quot;font-size:40px;color:red;&quot;&gt;立即登录&lt;/a&gt;&apos;; &#125;else&#123; echo &quot;&lt;span style=&quot;font-size:40px;color:red;&quot;&gt;注册失败&lt;/span&gt;&quot;; echo &apos;&lt;a href=&quot;../html/reg.html&quot; style=&quot;font-size:40px;color:red;&quot;&gt;重新注册&lt;/a&gt;&apos;; &#125;;?&gt;]]></content>
      <categories>
        <category>AJAX</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步（sync）与异步(async)编程]]></title>
    <url>%2F2017%2F10%2F09%2F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[同步与异步同步：在进程中任务未结束时需等待结束才能执行下一个任务 异步：在进程中任务未结束但在等待的过程中可先去执行下一个任务 js是属于单线程，所以我们最好采用异步编程 单线程：所有的任务由一个线程来完成 多线程：多个任务可分配给不同的线程来完成 js中的异步编程：1.定时器属于异步编程（到时间点后才开始执行，当时间设置为0也不会立即执行=&gt; 浏览器有延迟时间：谷歌：5~6ms IE：10~13ms） 2.事件绑定属于异步编程（事件触发时才执行） 3.回调函数也可理解为异步编程 4.在AJAX中可以使用异步编程 同步异步案例理解1234567891011121314151617181920212223242526272829303132333435//案例一var count = 0;window.setTimeout(function () &#123; count++; console.log(count);//后输出=&gt;1 1000ms后&#125;, 1000);console.log(count); //先输出=&gt;0//案例二var count = 0;window.setTimeout(function () &#123; count++; console.log(count);//后输出=&gt;1 不会立马执行，需要等待一段时间 谷歌：5~6ms IE：10~13ms&#125;,0);console.log(count); //先输出=&gt;0//案例三 var count = 0;window.setTimeout(function () &#123; count++; console.log(count); //不输出：因为线程一直被死循环占用，定时器需要一直等待着&#125;,1000);console.log(count); //先输出=&gt;0while(1)&#123; //死循环&#125;//案例四window.setTimeout(function () &#123; console.log(&apos;a&apos;); //再输出a&#125;,10);window.setTimeout(function () &#123; console.log(&apos;b&apos;); //先输出b 因为在等待队列中是按时间排序的 时间短的先执行&#125;,6);var i=0;while(i&lt;1000000000)&#123; i++;&#125; AJAX中的同步与异步编程AJAX中的同步：当AJAX任务开始时（xhr.send），一直需要到 READY STATE===4的时候任务才结束，才可以执行下一个任务 AJAX中的异步：当AJAX任务开始时（xhr.send），不需要等待READY STATE===4,期间可以执行其他任务，当READY STATE===时，再做相关操作 AJAX中的三部曲12345678910var xhr=new XMLHttpRequest();xhr.open(&quot;GET&quot;,&quot;/list&quot;,true);/* xhr.onreadystatechange=function()&#123; if(xhr.readystate===4&amp;&amp;xhr.status===200)&#123; ...... &#125; &#125; */xhr.send(null);//只有send之后AJAX任务（向服务器发送请求）才开始 AJAX中案例理解12345678910111213141516171819202122232425262728293031//案例一var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,true); //readyState===1xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); //输出： 2 3 4&#125;xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4//案例二var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,false); //readyState===1xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); //输出：4 （同步） 当请求结束 readyState==4时才输出 ajax本身是异步方法 （xhr保存开始时值1，当任务结束时值为4 状态码由1-&gt;4 输出4）&#125;xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4//案例三var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,true); //readyState===1xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); //输出：2 3 4 （异步-&gt;不需要等待状态码为4 -&gt;直接执行以下任务）&#125;//案例四var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,false); //readyState===1xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); // 无输出 （同步-&gt;状态码已为4时才添加事件-&gt;状态码不再改变触发事件-&gt;无输出）&#125; 获取服务器时间状态码（readyState）为2时就需进行的操作（需异步） =&gt;如获取响应头中的服务器时间（Date）=&gt; 可应用于电商网站倒计时抢购（若用客户端时间则用户可更改客户端时间） 虽状态码为4时可获取服务器响应头中的时间，但状态码从2-&gt;3-&gt;4占大量时间 当状态码为2时获取可节省时间 减小时间误差 12345678910111213141516171819202122var xhr = new XMLHttpRequest(); //readyState===0xhr.open(&quot;HEAD&quot;, &quot;./a.json&quot;, true); //readyState===1xhr.setRequestHeader(&quot;H51806&quot;,&quot;fang&quot;); //客户端设置请求头信息到a.json上-&gt;服务器端获取 （需写在open方法后）xhr.timeout=&quot;1000&quot;;//设置AJAX请求的超时时间（若为同步编程，请求时间超过设置时间时放弃请求，执行下列任务）/* 常用HTTP方法： GET:一般用于从服务器获取数据（给服务器数据少，获取数据多，此方法最常用）-&gt;问号传参 POST:一般用于推送数据给服务器（给服务器多，获取少） -&gt;请求主体传参 PUT:一般用于给服务器增加资源文件（上传图片功能） DELETE:一般用于从服务器删除资源文件 HEAD:一般用于获取服务器响应头信息 这些请求方式不管是哪一种都可以向服务器获得或者传递数据，且从本质意义上无区别，只是行业内被开发者人约定俗成了各自不同的用处，并非标准。*/xhr.onreadystatechange = function () &#123; //绑定事件 if (xhr.readyState === 2) &#123; // xhr.getResponseHeader=&gt;客户端获取服务器的响应头信息 var time = xhr.getResponseHeader(&quot;Date&quot;); console.log(time); //输出的为格林尼治时间（GMT） console.log(new Date(time)); //输出为中国标准时间（GMT+0800） &#125; &#125;xhr.send(null);]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX中的HTTP请求方式]]></title>
    <url>%2F2017%2F10%2F07%2FHTTP-METHOD%2F</url>
    <content type="text"><![CDATA[HTTP METHODHTTP常用的几种请求方式： 1.GET 2.POST 3.PUT 4.DELETE 5.HEAD 这些请求方式不管是哪一种都可以向服务器请求获取数据或者传递数据，从本质上无区别，只是在行业内被开发人员约定俗成各自不同的用处，并非是一种标准。 方法分析1.GET:一般用于从服务器获取数据（给服务器数据少，获取数据多，此方法最为常用） 2.POST:一般用于推送数据给服务器（给服务器多，获取数据少） 3.PUT：一般用于向服务器传递资源文件（上传图片功能） 4.DELETE:一般用于删除服务器资源文件 5.HEAD:一般用于获取服务器响应头信息 GET PK POST传递方式： GET:向服务器传递内容一般通过&quot;URL问号传参方式&quot; xhr.open(&quot;GET&quot;,&quot;/getlist?a=2&amp;num=4&quot;,true); POST:向服务器传递内容一般通过&quot;请求主体的方式&quot; xhr.open(&quot;POST&quot;,&quot;/postlist&quot;,true); xhr.send(&apos;{&quot;name&quot;:&quot;fang&quot;,&quot;age&quot;:&quot;22&quot;}&apos;); //传递的为JSON对象格式的字符串 大小问题： GET请求传递给服务器的内容存在大小限制，而POST理论上无限制（实际一般最大2MB） 原因：GET是通过URL传参形式，而每个浏览器对URL长度有限制，谷歌8KB，火狐7KB，IE2KB,所以当兼容IE情况下最大上传2KB大小内容。 缓存问题： GET请求会出现缓存 =&gt; 因为请求地址与传参相同（不一定是304），POST请求无缓存 在项目中我们的GET请求一般不允许出现缓存 =&gt; “清除缓存” =&gt; 改变URL =&gt; 在URL末尾追加一个随机数 =&gt; xhr.open(&quot;GET&quot;,&quot;/getlist?a=2&amp;num=5&amp;_=&quot;+Math.random(),true); 安全问题： 一般来说GET不安全（URL传参）,而POST相对安全 实际当攻击者想攻击时都不安全]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式（发布/订阅模式）]]></title>
    <url>%2F2017%2F10%2F02%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。 说的简单些，就是在数据发生改变时，对应的处理函数自动执行。维基的定义中涉及到了主动发出通知，按照这种方式，在angularJS中的事件广播更是中规中矩，但是其缺点是代码的可维护性较差。那么如果不进行主动通知，而是在进行对象属性值设置时，调用相关的处理函数，也可达到同等效果。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 页面加载时自动执行 var Observer = (function() &#123; // 为了防止消息被外部修改，将消息变量设为私有变量 var _message = &#123;&#125;; return &#123; // 注册信息接口 regist: function(type, fn) &#123; // 判断消息类型是否存在 if (typeof _message[type] === &apos;undefined&apos;) &#123; // 将动作推送到消息队列中执行 _message[type] = [fn]; &#125; else &#123; // 将动作方法推入到对应类型的队列中 _message[type].push(fn); &#125; &#125;, // 发布消息接口 fire: function(type, args) &#123; //如果该消息没有被注册，直接结束 if (!_message[type]) return; var events = &#123; type: type, //消息的类型 args: args || &#123;&#125; //消息所携带的数据 &#125; i = 0, //消息循环变量 len = _message[type].length; //消息动作的长度 for (; i &lt; len; i++) &#123; //依次执行注册消息所对应的动作序列 _message[type][i].call(this, events); &#125; &#125;, // 移除信息接口 remove: function(type, fn) &#123; // 如果消息队列存在 if (_message[type] instanceof Array) &#123; //从最后一个消息动作开始遍历 var i = _message[type].length - 1; for (; i &gt;= 0; i--) &#123; _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1); &#125; &#125; &#125; &#125; &#125;)(); //订阅消息 Observer.regist(&apos;news&apos;, function(e) &#123; console.log(e.type, e.args.msg); &#125;); Observer.regist(&apos;weather&apos;, function(e) &#123; console.log(e.args.title); console.log(e.args.msg); &#125;); Observer.regist(&apos;weather&apos;, function(e) &#123; console.log(e.args.title); console.log(e.args.msg); &#125;); //发布消息 Observer.fire(&apos;news&apos;, &#123; msg: &apos;新闻主体内容&apos; &#125;); Observer.fire(&apos;weather&apos;, &#123; title: &apos;杭州天气&apos;, msg: &apos;晴转多云 21-36°C&apos; &#125;); Observer.fire(&apos;weather&apos;, &#123; title: &apos;上海天气&apos;, msg: &apos;晴转多云 22-36°C&apos; &#125;);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX兼容与惰性思想]]></title>
    <url>%2F2017%2F09%2F28%2FAJAX%2F</url>
    <content type="text"><![CDATA[JS编程技巧:惰性思想所谓的惰性思想可以简单地理解为:只执行一次可以搞定的事，绝不执行多次。 惰性思想代码块:12345678910111213141516var utils=(function()&#123; var flag=&quot;getComputedStyle&quot; in window; //若返回true则为标准浏览器，false为IE8及以下浏览器 function getCss()&#123; if(flag)&#123; //因为以上已判断此浏览器结果并保存,直接使用flag而不需要用window.getComputedStyle判断 &#125;else&#123; &#125; &#125; return&#123; getCss:getCss; &#125;&#125;)()utils.getCss();utils.getCss();utils.getCss(); 惰性思想创建AJAX对象利用函数创建且兼容所有浏览器 源代码1234567891011121314151617181920212223242526272829303132333435363738var createXHR = function () &#123; var xhr = null, flag=false, //判断浏览器是否支持AJAX // 定义一个数组用于存放创建AJAX对象的各种方法 arr = [ function () &#123; return new XMLHttpRequest(); //只兼容IE7及以上 &#125;, // 以下三种方法兼容低版本浏览器 function () &#123; return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;, function () &#123; return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125;, function () &#123; return new ActiveXObject(&quot;Msxml3.XMLHTTP&quot;); &#125; ]; // 遍历这个数组中的小方法,当可用时即可取用 for (var i = 0; i &lt; arr.length; i++) &#123; var curFn = arr[i]; //获取当前遍历到的小方法 try &#123; // 本次循环获取的方法执行没有报错：说明此方法可用，下次直接执行此小方法即可=&gt;将createXHR重写为此小方法 xhr = curFn(); createXHR = curFn; flag = true; //浏览器可兼容AJAX则为true; break; //结束循环 &#125; catch (e) &#123; //本次获取的方法执行报错则继续循环遍历下一个方法 &#125; if (!flag) &#123; throw new Error(&quot;please updata your brower&quot;); //浏览器不支持AJAX时抛出错误 &#125; &#125; return xhr;&#125;;]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas实现五子棋小游戏]]></title>
    <url>%2F2017%2F09%2F17%2FCanvas%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[实现过程解析 绘制一个1024*768大小的画布，画布背景颜色填充为#e0c590 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;cheet&lt;/title&gt; &lt;style type="text/css"&gt; *&#123;padding: 0; margin: 0;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="1024" height="768" onmousedown="chessCheck()"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var myCanvas = document.getElementById("myCanvas"), ctx = myCanvas.getContext("2d");//getContext("2d") 对象是内建的 HTML5 对象 ctx.fillStyle = "#e0c590"; ctx.fillRect(0,0,1024,768); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; //创建一个1024*768大小的画布，填充颜色#e0c590 这里采用的canvas绘制出棋盘，使用table或div也可达到同样效果；使用moveTo/lineTo画线条，arc画圆，beginPath/closePath防止画的点线之间的相互影响，算好坐标就可以绘制出较为标准的棋盘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ctx.font = "30px Arial"; ctx.fillStyle = "#000"; ctx.fillText("不知道叫什么名字的五子棋游戏",100,60); //绘制实心标题文字 for (var i = 0; i &lt; 15; i++) &#123; ctx.beginPath(); ctx.moveTo(100, 100 + 40 * i); ctx.lineTo(660, 100 + 40 * i); ctx.stroke(); ctx.closePath(); //循环绘制棋盘横线 ctx.beginPath(); ctx.moveTo(100 + 40 * i, 100); ctx.lineTo(100 + 40 * i, 660); ctx.stroke(); ctx.closePath(); //循环绘制棋盘竖线 &#125; ctx.beginPath(); ctx.arc(220,220,5,0,2*Math.PI); ctx.fill(); ctx.closePath(); ctx.beginPath(); ctx.arc(540,220,5,0,2*Math.PI); ctx.fill(); ctx.closePath(); ctx.beginPath(); ctx.arc(380,380,5,0,2*Math.PI); ctx.fill(); ctx.closePath(); ctx.beginPath(); ctx.arc(220,540,5,0,2*Math.PI); ctx.fill(); ctx.closePath(); ctx.beginPath(); ctx.arc(540,540,5,0,2*Math.PI); ctx.fill(); ctx.closePath(); //绘制棋盘5个小黑点 ctx.font = "10px Arial"; function textStyle(num)&#123; if (num &lt; 10) return " " + num; else return num; &#125; var letter = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O'] for (var i = 15; i &gt;= 1; i--) &#123; ctx.fillText(textStyle(i), 80, 105 + 40 * (15 - i)); //绘制左侧数字 ctx.fillText(letter[i - 1], 655 - 40 * (15 - i), 680); //绘制下方字母 &#125; 通过createLinearGradient和addColorStop实现了颜色渐变的效果，通过gameType判断游戏类型，其值存入本地cookie中，通过函数cookie(key, value, options)读取，改代码使用localstorage或其他方式存储gameType的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var gameType = cookie("gameType"); if (gameType == null) gameType =1; var grd = ctx.createLinearGradient(750, 0, 910, 0); grd.addColorStop(0,"#e0c590"); grd.addColorStop(0.5,"#ffa500"); grd.addColorStop(1,"#e0c590"); var grd2 = ctx.createLinearGradient(750, 0, 910, 0); grd2.addColorStop(0,"#e0c590"); grd2.addColorStop(0.5,"#74cdeb"); grd2.addColorStop(1,"#e0c590"); ctx.font = "30px Arial"; ctx.beginPath(); if (gameType == 1) &#123; ctx.fillStyle = grd2; ctx.fillRect(750,140,160,80); ctx.fillStyle = "#f00"; ctx.fillText("人人对战",770,190); &#125;else&#123; ctx.fillStyle = grd; ctx.fillRect(750,140,160,80); ctx.fillStyle = "#000"; ctx.strokeText("人人对战",770,190); &#125; ctx.closePath(); ctx.beginPath(); if (gameType == 2) &#123; ctx.fillStyle = grd2; ctx.fillRect(750,260,160,80); ctx.fillStyle = "#f00"; ctx.fillText("人机对战",770,310); &#125;else&#123; ctx.fillStyle = grd; ctx.fillRect(750,260,160,80); ctx.fillStyle = "#000"; ctx.strokeText("人机对战",770,310); &#125; ctx.closePath(); ctx.beginPath(); ctx.fillStyle = grd; ctx.fillRect(750,380,160,80); ctx.fillStyle = "#000"; ctx.strokeText("重新开始",770,430); ctx.closePath(); function cookie(key, value, options) &#123; if (typeof value === "undefined") &#123; // 读取 var cookies = document.cookie.split("; "); for (var i = 0, len = cookies.length; i &lt; len; i++) &#123; var cookie = cookies[i].split("="); if (decodeURIComponent(cookie[0]) === key) &#123; return decodeURIComponent(cookie[1]); &#125; &#125; return null; &#125; options = options || &#123;&#125;; var cookie = encodeURIComponent(key) + "=" + encodeURIComponent(value); if ((typeof options.expires) !== "undefined") &#123; if (typeof options.expires === "number") &#123; var days = options.expires, t = options.expires = new Date(); t.setDate(t.getDate() + days); &#125; cookie += ";expires=" + options.expires.toUTCString(); &#125; if (typeof options.path !== "undefined") cookie += ";path=" + options.path; if (typeof options.domain !== "undefined") cookie += ";domain=" + options.domain; if (options.secure) cookie += ";secure"; document.cookie = cookie; &#125; 现在棋盘绘制完成，开始实现逻辑功能，将棋盘各个位置同二维数组对应，初始化棋盘信息 123456for (var i = 0; i &lt; 15; i++) &#123; position[i] = new Array(); for (var j = 0; j &lt; 15; j++) &#123; position[i][j] = 0; //0表示所在位置无棋子 &#125; &#125; 利用e.clientX与e.clientY获取事件源坐标，通过处理和Math.round实现每个棋子对应的有效点击范围，gameType的值可以判断游戏类型，通过传入坐标以及棋子颜色drawChess(x,y,chessColor)绘制对应棋子 123456789101112131415161718192021222324252627282930function chessCheck(e)&#123; e = e || arguments.callee.caller.arguments[0] || window.event; //arguments.callee.caller.arguments[0]为firefox的兼容处理 var ordinateX = e.clientX - 100 + getScroll("left"), ordinateY = e.clientY - 100 + getScroll("top"), //获取鼠标点击坐标点 x = Math.round(parseFloat(ordinateX / 40)), y = Math.round(parseFloat(ordinateY / 40)); //将坐标点转换为旗子位置 clickType(ordinateX, ordinateY); if (ordinateX &lt; 0 || ordinateY &lt; 0 || ordinateX &gt; 560 || ordinateY &gt; 560 || position[x][y] != 0) &#123; //console.log("error"); //排除棋子位置超出棋盘和当前位置棋子已经存在的情况 return; &#125; if (gameState === "over") &#123; if (countNum % 2 == 0) alert("游戏结束，白色方获胜!"); else alert("游戏结束，黑色方获胜!"); return; &#125; if (gameType == 1) &#123; //人人对战，判断当前棋子颜色 if (countNum % 2 == 0) chessColor = "#000"; else chessColor = "#fff"; countNum ++; drawChess(x,y,chessColor); &#125;else if(gameType ==2)&#123; //人机对战 chessColor = "#000"; drawChess(x,y,chessColor); AIplay(); &#125; &#125; 12345678910111213141516171819function drawChess(x,y,chessColor)&#123; ctx.fillStyle = chessColor; ctx.beginPath(); ctx.arc(100 + x * 40, 100 + y * 40, 12, 0, 2 * Math.PI, true) ctx.fill(); ctx.closePath(); if (chessColor == "#000") &#123; position[x][y] = 2; isWin(x, y, chessColor); //if(isWin(x,y,chessColor)) win(); //console.log("黑落子的位置位于：",x,y); &#125; if (chessColor == "#fff") &#123; position[x][y] = 1; isWin(x, y, chessColor); //if(isWin(x,y,chessColor)) win(); //console.log("白落子的位置位于：",x,y); &#125; &#125; 每次落子之后进行游戏是否结束的判断，包括横竖左斜右斜四个方向的判断，任何一个方向连成5子游戏结束，这里以横方向作为介绍。当落子后从本身开始向左遍历有多少相同颜色的棋子，再从本身开始向右遍历有多少相同颜色的棋子，两次结果想加大于6(落下的棋子加了两次)结束游戏，否则依次进行竖左斜右斜的判断。胜利条件成立执行isOver()实现五子连线以及结束提示 123456789101112131415161718192021222324function heng(temp, x, y) &#123; var arr = new Array(4), count = 0; for (var i = x; i &gt;= 0; i--) &#123; arr[0] = i; arr[1] = y; if (position[i][y] == temp) count++; else &#123; arr[0] = ++i; break; &#125; &#125; for (var i = x; i &lt;= 14; i++) &#123; arr[2] = i; arr[3] = y; if (position[i][y] == temp) count++; else &#123; arr[2] = --i; break; &#125; &#125; if(count &gt;= 6) isOver(arr[0], arr[1], arr[2], arr[3], temp); &#125; //分别向落子两边遍历结果想加 同样通过点击获取的坐标判断右侧功能键(人人，人机，重新开始)的触发 12345678910111213141516function clickType(ordinateX,ordinateY)&#123; //实现右侧选择项功能 var x = ordinateX, y = ordinateY; if (x &gt;= 650 &amp;&amp; x &lt;= 810 &amp;&amp; y &gt;= 40 &amp;&amp; y &lt;= 120) &#123; cookie("gameType", 1, &#123;expires:7&#125;); location.reload(); &#125; if (x &gt;= 650 &amp;&amp; x &lt;= 810 &amp;&amp; y &gt;= 160 &amp;&amp; y &lt;= 240) &#123; cookie("gameType", 2, &#123;expires:7&#125;); location.reload(); &#125; if (x &gt;= 650 &amp;&amp; x &lt;= 810 &amp;&amp; y &gt;= 280 &amp;&amp; y &lt;= 360) &#123; if (confirm("重新开始游戏?")) location.reload(); &#125; &#125;]]></content>
      <categories>
        <category>Canvas</category>
        <category>JavaScript</category>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>JavaScript</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现文字跑马灯]]></title>
    <url>%2F2017%2F09%2F05%2F%E8%B7%91%E9%A9%AC%E7%81%AF%2F</url>
    <content type="text"><![CDATA[跑马灯思想所谓的跑马灯即类似于循环播放的通知告示等等效果。 主要利用元素嵌套产生的横向滚动条来控制循环滚动。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;跑马灯&lt;/title&gt; &lt;style&gt; #box&#123; background: pink; border: 1px dashed black; width: 608px; height: 20px; margin: 0 auto; &#125; #begin&#123; white-space: nowrap; float: left; &#125; #end&#123; white-space: nowrap; &#125; #movebox&#123; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;movebox&quot;&gt; &lt;div id=&quot;begin&quot;&gt; &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。 &lt;/div&gt; &lt;div id=&quot;end&quot;&gt; &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var movebox=document.getElementById(&apos;movebox&apos;); var begin=document.getElementById(&apos;begin&apos;); var beginWidth=window.getComputedStyle(begin,null).width; //获取元素宽度 自带单位（px） // console.log(beginWidth); //string类型 var beginw=beginWidth.replace(/px/,&quot;&quot;); //去除px单位 // console.log(beginw); var timer=window.setInterval(function()&#123; var curLeft=movebox.scrollLeft; //获取当前加之前的scrollleft值 movebox.scrollLeft=curLeft+1; //每隔10毫秒就使文字盒子水平滚动条在当前值上加1 var newLeft=movebox.scrollLeft; //获取当前加之后的left值console.log(newLeft); // 当scrollLeft值大于等于第一个div宽度时重置位置 if(newLeft&gt;=beginw)&#123; movebox.scrollLeft=0; &#125; &#125;,10)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇了解一下]]></title>
    <url>%2F2017%2F08%2F28%2F%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[利用Canvas与JavaScript实现贪吃蛇##实现思路 先把蛇画出来 定义一下蛇的结构，用一个数组保存一堆矩形，包含蛇头（红）和蛇身（灰）。 画蛇（初始状态） 蛇能动（重点） 蛇移动方式：自始至终都只有蛇头在动 画一个灰色的方块，位置与蛇头重叠 将这个方块插到数组中蛇头后面一个的位置arrar.splice(0,1,rect) 砍去末尾的方块array.pop() 将蛇头向设定方向移动一格 需要一个保存方向的变量(direction) 根据方向进行移动，一次移动一个格 根据按键改方向 随机投放食物 需要随机食物的位置 需要判断食物在不在蛇身上。 吃食物 判断食物是否与蛇头重叠 数组加一个元素（少删除一个元素就是加一个元素） 生成新的食物 gameover 撞墙判定 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #canvas&#123; box-shadow: 0 5px 40px black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas" width="800" height="500"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); //构造对象方块 function Rect (x,y,w,h,color) &#123; this.x = x; this.y = y; this.w = w; this.h = h; this.color = color; &#125; //画方块的方法 Rect.prototype.draw = function () &#123; context.beginPath(); context.fillStyle = this.color; context.rect(this.x,this.y,this.w,this.h); context.fill(); context.stroke(); &#125; //构造对象蛇 function Snake () &#123; //定义一个空数组存放组成整蛇的方块对象 var snakeArray = []; //画出4个方块，设置成灰色 for (var i = 0; i &lt; 4; i++) &#123; var rect = new Rect(i*20,0,20,20,"gray"); //之所以用splice（往前加）而不是用push（往后加），是为了让蛇头出现在数组第一个位置 snakeArray.splice(0,0,rect); &#125; //把数组第一个作为蛇头，蛇头设成红色 var head = snakeArray[0]; head.color = "red"; //此处将两个后面常用的东西定为属性，方便后面调用 this.head = snakeArray[0]; //蛇头 this.snakeArray = snakeArray; //整蛇数组 //给定初始位置向右(同keyCode右箭头) this.direction = 39; &#125; //画蛇的方法 Snake.prototype.draw = function () &#123; for (var i = 0; i &lt; this.snakeArray.length; i++) &#123; this.snakeArray[i].draw(); &#125; &#125; //蛇移动的方法 Snake.prototype.move = function () &#123; //此处是核心部分，蛇的 移动方式 //1、画一个灰色的方块，位置与蛇头重叠 //2、将这个方块插到数组中蛇头后面一个的位置 //3、砍去末尾的方块 //4、将蛇头向设定方向移动一格 var rect = new Rect(this.head.x,this.head.y,this.head.w,this.head.h,"gray"); this.snakeArray.splice(1,0,rect); //判断是否吃到食物，isEat判定函数写在最后了 //吃到则食物重新给位置，不砍去最后一节，即蛇变长 //没吃到则末尾砍掉一节，即蛇长度不变 if (isEat())&#123; food = new getRandomFood(); &#125;else&#123; this.snakeArray.pop(); &#125; //设置蛇头的运动方向，37 左，38 上，39 右，40 下 switch (this.direction) &#123; case 37: this.head.x -= this.head.w break; case 38: this.head.y -= this.head.h break; case 39: this.head.x += this.head.w break; case 40: this.head.y += this.head.h break; default: break; &#125; // gameover判定 // 撞墙 if (this.head.x &gt; canvas.width || this.head.x &lt; 0 || this.head.y &gt; canvas.height || this.head.y &lt; 0)&#123; clearInterval(timer); &#125; // 撞自己，循环从1开始，避开蛇头与蛇头比较的情况 for (var i = 1; i &lt; this.snakeArray.length; i++) &#123; if (this.snakeArray[i].x == this.head.x &amp;&amp; this.snakeArray[i].y == this.head.y)&#123; clearInterval(timer); &#125; &#125; &#125; //画出初始的蛇 var snake = new Snake() snake.draw(); //画出初始的食物 var food = new getRandomFood() //定时器 var timer = setInterval(function () &#123; context.clearRect(0,0,canvas.width,canvas.height); food.draw(); snake.move(); snake.draw(); &#125;, 100) //键盘事件，其中的if判定是为了让蛇不能直接掉头 document.onkeydown = function (e) &#123; var ev = e||window.event; switch(ev.keyCode)&#123; case 37:&#123; if (snake.direction !== 39)&#123; snake.direction = 37; &#125; break; &#125; case 38:&#123; if (snake.direction !== 40)&#123; snake.direction = 38; &#125; break; &#125; case 39:&#123; if (snake.direction !== 37)&#123; snake.direction = 39; &#125; break; &#125; case 40:&#123; if (snake.direction !== 38)&#123; snake.direction = 40; &#125; break; &#125; &#125; ev.preventDefault(); &#125; //随机函数，获得[min,max]范围的值 function getNumberInRange (min,max) &#123; var range = max-min; var r = Math.random(); return Math.round(r*range+min) &#125; //构建食物对象 function getRandomFood () &#123; //判定食物是否出现在蛇身上，如果是重合，则重新生成一遍 var isOnSnake = true; //设置食物出现的随机位置 while(isOnSnake)&#123; //执行后先将判定条件设置为false，如果判定不重合，则不会再执行下列语句 isOnSnake = false; var indexX = getNumberInRange(0,canvas.width/20-1); var indexY = getNumberInRange(0,canvas.height/20-1); var rect = new Rect(indexX*20, indexY*20, 20, 20, "green"); for (var i = 0; i &lt; snake.snakeArray.length; i++) &#123; if(snake.snakeArray[i].x == rect.x &amp;&amp; snake.snakeArray[i].y == rect.y)&#123; //如果判定重合，将其设置为true，使随机数重给 isOnSnake = true; break; &#125; &#125; &#125; //返回rect，使得实例化对象food有draw的方法 return rect; &#125; //判定吃到食物，即蛇头坐标与食物坐标重合 function isEat () &#123; if (snake.head.x == food.x &amp;&amp; snake.head.y == food.y)&#123; return true; &#125; else &#123; return false; &#125; &#125;&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Canvas</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现回到页面顶部]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%2F</url>
    <content type="text"><![CDATA[实现效果1.右下角按钮回到顶部(点击后按钮消失，随即页面滑动到顶部;页面下拉距离超过一屏幕显示回到顶部按钮，反之按钮消失) 2.列表hover时显示随机颜色(利用时间委托机制) 3.点击左侧列表，页面滑动到对应模块(通过获取所点击列表的ID值滑动到对应CLASS值相同的模块) 点击查看源代码 代码分析回到顶部按钮1.获取当前scrollTop距离（var distance=document.documentElement.scrollTop||document.body.scrollTop） 2.总时间(var timer=500;单位：ms) 总共需要运动500ms 3.频率( var frequency=10;单位：ms) 每10ms运动一次 4.步长(var step=distance/timer*frequency) 每毫秒运动距离*频率=每一次运动所需步长 回到顶部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344var span = document.getElementsByTagName(&apos;span&apos;)[0];var i = document.getElementsByTagName(&apos;i&apos;)[0];var timer = 1000; //总时间var frequency = 5; //频率window.onscroll = show;function show() &#123; var dis = document.documentElement.scrollTop || document.body.scrollTop; var windis = window.screen.height; //屏幕分辨率高度 // console.log(windis); //当前滚动条距离大于一个屏幕高度时显示回到顶部按钮 if (dis &gt;= windis) &#123; span.style.display = &apos;block&apos;; i.style.display = &apos;block&apos;; &#125; else &#123; //当前滚动条距离小于一个屏幕高度时隐藏回到顶部按钮 span.style.display = &apos;none&apos;; i.style.display = &apos;none&apos;; &#125;&#125;;span.addEventListener(&apos;click&apos;, function (e) &#123; span.style.display = &apos;none&apos;; //单击后虽然设置为隐藏，但是由于滚动条顶部距离大于屏幕高度又触发上一个事件，使其又显示，所以当点击时需要阻止上一个事件发生； i.style.display = &apos;none&apos;; window.onscroll = null; //点击后阻止前一个DOM 0级事件 二级事件无法用此方法阻止 e = e || event; var disTop = document.documentElement.scrollTop || document.body.scrollTop; //获取运动前滚动条顶部距离 var step = (disTop / timer) * frequency; //步长 //定时器：每隔一定频率运动距离 var intime = window.setInterval(function () &#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离 if (curTop === 0) &#123; window.clearInterval(intime); //当距离为0时清除定时器 window.onscroll = show; return; //中断执行 &#125; else &#123; curTop -= step; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长 &#125; //每隔frequency时间设置一次滚动条距离 document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;, frequency);&#125;); 列表随机颜色1.利用事件委托机制给父级DIV加一个mouseover事件 2.mouseover在其子对象li上时触发事件，获取触发事件的目标(var elem = e.target;),对此目标进行操作 3.定义一个数组存放十六进制数，用于组成随机十六进制颜色，生成6个随机数(0-15)作为数组下标，将对应值存入一个空数组并转为字符串，即为十六进制颜色。 随机颜色代码12345678910111213141516171819202122232425var items = document.getElementsByTagName(&apos;li&apos;);var ul = document.getElementsByTagName(&apos;ul&apos;);// console.log(ul[0]);//事件委托：给父元素添加触发事件ul[0].addEventListener(&apos;mouseover&apos;, function (e) &#123; e = e || event; var elem = e.target; //获取目标 elem.style.background = null; // 每一次触发事件都先初始化 var num = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; //十六进制颜色 var colorNum = []; do &#123; var randomNum = Math.floor(Math.random() * 16); //0-15 //随机的0-15之间的一个数字作为十六进制数组下标 colorNum.push(num[randomNum]); &#125; while (colorNum.length &lt; 6); //将获取的6个随机数到空数组 // console.log(colorNum); var colorstr = colorNum.join(&apos;&apos;); //转为字符串 // console.log(colorstr); elem.style.background = &quot;#&quot; + colorstr; //设置随机颜色&#125;);//鼠标离开时清空颜色ul[0].addEventListener(&apos;mouseout&apos;, function (e) &#123; e = e || event; var elem = e.target; elem.style.background = null;&#125;); 滑动模块1.与获取随机颜色原理相同，需要利用事件委托，通过给父元素DIV加点击事件获取目标事件 2.获取所点击目标的ID值，寻找模块中CLASS值与ID值相同的模块，并获取其距离顶部高度 3.需要设置过渡动画效果则与按钮部分相同需要设置运动总时间、总距离、频率等 滑动模块代码12345678910111213141516171819202122232425262728293031ul[0].addEventListener(&apos;click&apos;, function (e) &#123; e = e || event; var liElem = e.target; //利用时间委托获取目标 var liName = liElem.getAttribute(&apos;id&apos;) //获取目标id值 var divName = document.getElementsByClassName(liName)[0]; //获取对应名称的DIV模块元素 var top = divName.offsetTop; //获取对应的滚动条高度 var timer = 500; //总时间 var frequencytwo = 3; //频率 if (top &lt; timer) &#123; top += 500; &#125; var stepgo = (top / timer) * frequencytwo; //步长 //定时器：每隔一定频率运动距离 var intn = window.setInterval(function () &#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离 if (curTop === top) &#123; window.clearInterval(intn); //当两者相同时清除定时器 return; //中断执行 &#125; if (curTop &gt; top) &#123; curTop -= stepgo; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长 &#125; if (curTop &lt; top) &#123; curTop += stepgo; &#125; //每隔frequency时间设置一次滚动条距离 document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;, frequencytwo);&#125;); 本人才疏学浅，暂时只能展示所知显浅部分，有误或可改进之处请留言告知 ◕‿-]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
