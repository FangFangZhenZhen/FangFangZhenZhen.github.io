<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库注册用户功能实现]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[数据库注册功能实现分析最近模仿百度云写了一套页面,先简单记录一下注册功能的实现 0.检测数据库中用户名是否已存在并将结果显示到前端（通过AJAX的GET请求,连接到PHP查询用户名页,PHP查询页内容为连接数据库并检索数据库中前端传递来的用户名是否已存在,将结果以JSON字符串对象形式返回到前端） 1.提交HTML表单数据到后台PHP获取 2.PHP获取前端表单内name属性值 3.PHP连接数据库检测用户名是否已存在 4.不存在则向数据库插入新用户信息 数据库设计图效果图如下 注册功能表单HTML代码HTML完整代码1234567891011121314151617181920212223242526272829&lt;form id=&quot;_san_7&quot; class=&quot;san-form&quot; method=&quot;POST&quot;&gt; &lt;!-- 用户名 --&gt; &lt;div id=&quot;_san_9&quot; class=&quot;san-form-item san-form-item-userName&quot;&gt; &lt;div id=&quot;_san_11&quot; class=&quot;san-form-item-content&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;_san_13&quot; name=&quot;uname&quot; placeholder=&quot;用户名&quot;&gt; &lt;label id=&quot;_san_81&quot; class=&quot;invalid-label&quot;&gt;&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 密码 --&gt; &lt;div id=&quot;_san_15&quot; class=&quot;san-form-item san-form-item-password&quot;&gt; &lt;div id=&quot;_san_17&quot; class=&quot;san-form-item-content&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;_san_19&quot; name=&quot;upwd&quot; placeholder=&quot;密码&quot;&gt; &lt;label id=&quot;_san_57&quot; class=&quot;invalid-label&quot;&gt;&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 确认密码 --&gt; &lt;div id=&quot;_san_21&quot; class=&quot;san-form-item san-form-item-confirmPassword&quot;&gt; &lt;div id=&quot;_san_23&quot; class=&quot;san-form-item-content&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;_san_25&quot; name=&quot;cpwd&quot; placeholder=&quot;确认密码&quot;&gt; &lt;label id=&quot;_san_59&quot; class=&quot;invalid-label&quot;&gt;&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注册 --&gt; &lt;div id=&quot;_san_41&quot; class=&quot;san-form-item&quot;&gt; &lt;div id=&quot;_san_43&quot; class=&quot;san-form-item-content&quot;&gt; &lt;button id=&quot;_san_45&quot; type=&quot;submit&quot; class=&quot;submit&quot;&gt;同意条款并注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 注册功能表单JS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// 用户名正则验证var userName = $(&apos;#_san_13&apos;);var form = $(&apos;#_san_7&apos;);var submit = $(&apos;#_san_45&apos;);var userReg = /^[A-Za-z\d_-]&#123;6,32&#125;$/; //用户名正则var userError = $(&apos;#_san_81&apos;); //用户名错误文本userName.on(&quot;keyup&quot;, function () &#123; if (userReg.test(userName.val())) &#123; userName.css(&quot;border-color&quot;, &quot;#ccc&quot;); userError.text(&quot;&quot;) &#125; if (!userReg.test(userName.val())) &#123; userName.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 userName.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 userError.text(&quot;用户名长度必须是6-32个字符之间&quot;) //错误内容 &#125; if (userName.val() == &quot;&quot;) &#123; userName.css(&quot;outline&quot;, &quot;none&quot;); userError.text(&quot;用户名必填&quot;) userName.css(&quot;border-color&quot;, &quot;red&quot;); &#125;&#125;);// 用户名数据库验证//1.完成用户名称的重复性验证（异步，检查数据库中是否已存在当前用户名）//异步请求数据，因为还要输入下面的数据，不能跳转到php页面去验证userName.on(&quot;blur&quot;, function () &#123; //1.创建XHR对象 创建异步对象 var xhr = null; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); //标准创建 &#125; else &#123; //IE6及以下的创建方式 xhr = new ActiveXObject(&quot;Microsoft.XMLHttp&quot;); &#125; //2.创建请求 var uname = userName.val(); //获取输入框里的值，把用户名传到后端，再查询 var url = &quot;../php/check-name.php?uname=&quot; + uname; xhr.open(&quot;get&quot;, url, true); //查询用户名称，用get方法就行，去数据库查询，看用户名是否已经存在 //查询用get就行，向服务器提交数据时再用post //3.设置回调函数，监听状态 //参数true，异步 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; //判断状态，xhr请求状态为4，表示接收响应数据成功；当status的值是200的时候，表示服务器已经正确的处理请求以及给出响应 var resultStr = xhr.responseText; var resultJson =JSON.parse(resultStr); if (resultJson==&apos;true&apos;) &#123; // userError.text(&quot;用户名可用&quot;); &#125; else &#123; form.removeAttr(&quot;action&quot;); userName.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 userName.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 userError.text(&quot;用户名已存在&quot;); &#125; // console.log(resultJson==&apos;false&apos;); //提示内容 &#125;; &#125;; //4.发送请求 xhr.send(null); //get请求，参数写null&#125;);// 密码正则验证var pwd = $(&apos;#_san_19&apos;);var pwdReg = /^.*(?=.&#123;6,32&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/; //密码正则(6-32位且至少1个大写字母，1个小写字母，1个数字)var pwdError = $(&apos;#_san_57&apos;); //密码错误文本pwd.on(&quot;keyup&quot;, function () &#123; if (pwdReg.test(pwd.val())) &#123; //格式正确 pwd.css(&quot;border-color&quot;, &quot;#ccc&quot;); pwdError.text(&quot;&quot;); &#125; if (pwd.val().length &lt;= 6) &#123; //格式错误 pwd.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 pwd.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 pwdError.text(&quot;密码长度必须是6-32个字符之间&quot;) //错误内容 &#125; if (pwd.val().length &gt; 6 &amp;&amp; (!pwdReg.test(pwd.val()))) &#123; pwd.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 pwd.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 pwdError.text(&quot;密码必须包含数字、大小写英文字母&quot;) //错误内容 &#125; if (pwd.val() == &quot;&quot;) &#123; //密码为空 pwd.css(&quot;outline&quot;, &quot;none&quot;); pwdError.text(&quot;密码必填&quot;); pwd.css(&quot;border-color&quot;, &quot;red&quot;); &#125;&#125;);// 确认密码验证var pwdCheck = $(&apos;#_san_25&apos;);var pwdCheckReg = /^.*(?=.&#123;6,32&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/; //密码正则(6-32位且至少1个大写字母，1个小写字母，1个数字)var pwdCheckError = $(&apos;#_san_59&apos;); //确认密码错误文本pwdCheck.on(&quot;keyup&quot;, function () &#123; if (pwdCheckReg.test(pwdCheck.val()) &amp;&amp; pwdCheck.val() === pwd.val()) &#123; //确认密码正确 pwdCheck.css(&quot;border-color&quot;, &quot;#ccc&quot;); pwdCheckError.text(&quot;&quot;); &#125; if (pwdCheck.val().length &lt;= 6) &#123; //格式错误 pwdCheck.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 pwdCheck.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 pwdCheckError.text(&quot;确认密码长度必须是6-32个字符之间&quot;) //错误内容 &#125; if (pwdCheck.val().length &gt; 6 &amp;&amp; (!pwdCheckReg.test(pwdCheck.val()))) &#123; pwdCheck.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 pwdCheck.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 pwdCheckError.text(&quot;确认密码必须包含数字、大小写英文字母&quot;) //错误内容 &#125; if (pwdCheckReg.test(pwdCheck.val()) &amp;&amp; pwdCheck.val() != pwd.val()) &#123; //确认密码正确 pwdCheck.css(&quot;outline&quot;, &quot;none&quot;); //去除聚焦时的边框 pwdCheck.css(&quot;border-color&quot;, &quot;red&quot;); //设置错误时边框 pwdCheckError.text(&quot;两次输入的内容不一致&quot;) //错误内容 &#125; if (pwdCheck.val() == &quot;&quot;) &#123; //密码为空 pwdCheck.css(&quot;outline&quot;, &quot;none&quot;); pwdCheckError.text(&quot;确认密码必填&quot;); pwdCheck.css(&quot;border-color&quot;, &quot;red&quot;); &#125;&#125;);//判断是否可注册submit.on(&apos;mouseover&apos;, function () &#123; // 满足所有规则时向后台提交数据 if (userReg.test(userName.val()) == true&amp;&amp;pwdReg.test(pwd.val())==true&amp;&amp;pwdCheckReg.test(pwdCheck.val())==true &amp;&amp; (pwdCheck.val() === pwd.val())==true) &#123; form.attr(&quot;action&quot;, &quot;../php/reg.php&quot;); &#125; else &#123; form.removeAttr(&quot;action&quot;); &#125;&#125;); PHP检测数据库用户名代码1234567891011121314151617181920212223242526272829303132333435&lt;?php// 1.连接数据库 $conn = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;baidu&quot;); if (!$conn)&#123; echo &quot;Error: Unable to connect to MySQL.&quot; . PHP_EOL; echo &quot;Debugging errno: &quot; . mysqli_connect_errno() . PHP_EOL; echo &quot;Debugging error: &quot; . mysqli_connect_error() . PHP_EOL; exit; &#125;// 设置编码，防止中文乱码 mysqli_set_charset($conn, &quot;utf8&quot;);// 2.接收前端传过来的uname $uname=$_REQUEST[&quot;uname&quot;]; // 3.拼接sql，并查询uname是否存在 $sql=&quot; SELECT uname FROM register WHERE uname=&apos;$uname&apos;&quot;; $result=mysqli_query($conn,$sql);// 4.根据查询的结果输出相应$row=mysqli_fetch_row($result); //抓取一条数据，即当前uname对应的数据 $raw_success =&apos;true&apos;; $raw_fail =&apos;false&apos;; $res_success = json_encode($raw_success); $res_fail = json_encode($raw_fail); if($row==null)&#123; //如果$row为空，即数据库中没有相同的用户名存在 echo $res_success; &#125;else&#123; echo $res_fail; &#125;;?&gt; PHP检测是否可注册代码123456789101112131415161718192021222324252627282930313233&lt;?php// 1.获取请求提交的数据 $uname=$_REQUEST[&quot;uname&quot;]; //uname值就是前端页面中name属性的值 $upwd=$_REQUEST[&quot;upwd&quot;]; //确认密码不用获取，获取一个密码就行// 2.连接到数据库$conn = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;baidu&quot;);if (!$conn)&#123; echo &quot;Error: Unable to connect to MySQL.&quot; . PHP_EOL; echo &quot;Debugging errno: &quot; . mysqli_connect_errno() . PHP_EOL; echo &quot;Debugging error: &quot; . mysqli_connect_error() . PHP_EOL; exit;&#125;// 设置编码，防止中文乱码mysqli_set_charset($conn, &quot;utf8&quot;);// 3.写sql语句并执行$sql=&quot;INSERT INTO register (uname, upwd) VALUES (&apos;$uname&apos;,&apos;$upwd&apos;)&quot;;//字段值 外面用双引号，里面用单引号$result=mysqli_query($conn,$sql);//执行sql语句// 4.根据执行结果给出响应 if($result==true)&#123; //函数返回值 echo &quot;&lt;span style=&quot;font-size:40px;color:red;&quot;&gt;注册成功&lt;/span&gt;&quot;; echo &apos;&lt;a href=&quot;../html/login.html&quot; style=&quot;font-size:40px;color:red;&quot;&gt;立即登录&lt;/a&gt;&apos;; &#125;else&#123; echo &quot;&lt;span style=&quot;font-size:40px;color:red;&quot;&gt;注册失败&lt;/span&gt;&quot;; echo &apos;&lt;a href=&quot;../html/reg.html&quot; style=&quot;font-size:40px;color:red;&quot;&gt;重新注册&lt;/a&gt;&apos;; &#125;;?&gt;]]></content>
      <categories>
        <category>AJAX</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步（sync）与异步(async)编程]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[同步与异步同步：在进程中任务未结束时需等待结束才能执行下一个任务 异步：在进程中任务未结束但在等待的过程中可先去执行下一个任务 js是属于单线程，所以我们最好采用异步编程 单线程：所有的任务由一个线程来完成 多线程：多个任务可分配给不同的线程来完成 js中的异步编程：1.定时器属于异步编程（到时间点后才开始执行，当时间设置为0也不会立即执行=&gt; 浏览器有延迟时间：谷歌：5~6ms IE：10~13ms） 2.事件绑定属于异步编程（事件触发时才执行） 3.回调函数也可理解为异步编程 4.在AJAX中可以使用异步编程 同步异步案例理解1234567891011121314151617181920212223242526272829303132333435//案例一var count = 0;window.setTimeout(function () &#123; count++; console.log(count);//后输出=&gt;1 1000ms后&#125;, 1000);console.log(count); //先输出=&gt;0//案例二var count = 0;window.setTimeout(function () &#123; count++; console.log(count);//后输出=&gt;1 不会立马执行，需要等待一段时间 谷歌：5~6ms IE：10~13ms &#125;,0);console.log(count); //先输出=&gt;0//案例三 var count = 0;window.setTimeout(function () &#123; count++; console.log(count); //不输出：因为线程一直被死循环占用，定时器需要一直等待着&#125;,1000);console.log(count); //先输出=&gt;0while(1)&#123; //死循环&#125;//案例四window.setTimeout(function () &#123; console.log(&apos;a&apos;); //再输出a&#125;,10);window.setTimeout(function () &#123; console.log(&apos;b&apos;); //先输出b 因为在等待队列中是按时间排序的 时间短的先执行 &#125;,6);var i=0;while(i&lt;1000000000)&#123; i++;&#125; AJAX中的同步与异步编程AJAX中的同步：当AJAX任务开始时（xhr.send），一直需要到 READY STATE===4的时候任务才结束，才可以执行下一个任务 AJAX中的异步：当AJAX任务开始时（xhr.send），不需要等待READY STATE===4,期间可以执行其他任务，当READY STATE===时，再做相关操作 AJAX中的三部曲12345678910var xhr=new XMLHttpRequest();xhr.open(&quot;GET&quot;,&quot;/list&quot;,true);/* xhr.onreadystatechange=function()&#123; if(xhr.readystate===4&amp;&amp;xhr.status===200)&#123; ...... &#125; &#125; */xhr.send(null);//只有send之后AJAX任务（向服务器发送请求）才开始 AJAX中案例理解12345678910111213141516171819202122232425262728293031//案例一var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,true); //readyState===1xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); //输出： 2 3 4&#125;xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 //案例二var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,false); //readyState===1xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); //输出：4 （同步） 当请求结束 readyState==4时才输出 ajax本身是异步方法 （xhr保存开始时值1，当任务结束时值为4 状态码由1-&gt;4 输出4）&#125;xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 //案例三var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,true); //readyState===1xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); //输出：2 3 4 （异步-&gt;不需要等待状态码为4 -&gt;直接执行以下任务）&#125;//案例四var xhr=new XMLHttpRequest(); //readyState===0xhr.open(&quot;GET&quot;,&quot;./a.json&quot;,false); //readyState===1xhr.send(null); //任务开始 1-&gt;2-&gt;3-&gt;4 xhr.onreadystatechange=function()&#123; //绑定事件 console.log(xhr.readyState); // 无输出 （同步-&gt;状态码已为4时才添加事件-&gt;状态码不再改变触发事件-&gt;无输出）&#125; 获取服务器时间状态码（readyState）为2时就需进行的操作（需异步） =&gt;如获取响应头中的服务器时间（Date）=&gt; 可应用于电商网站倒计时抢购（若用客户端时间则用户可更改客户端时间） 虽状态码为4时可获取服务器响应头中的时间，但状态码从2-&gt;3-&gt;4占大量时间 当状态码为2时获取可节省时间 减小时间误差 12345678910111213141516171819202122var xhr = new XMLHttpRequest(); //readyState===0xhr.open(&quot;HEAD&quot;, &quot;./a.json&quot;, true); //readyState===1 xhr.setRequestHeader(&quot;H51806&quot;,&quot;fang&quot;); //客户端设置请求头信息到a.json上-&gt;服务器端获取 （需写在open方法后）xhr.timeout=&quot;1000&quot;;//设置AJAX请求的超时时间（若为同步编程，请求时间超过设置时间时放弃请求，执行下列任务）/* 常用HTTP方法： GET:一般用于从服务器获取数据（给服务器数据少，获取数据多，此方法最常用）-&gt;问号传参 POST:一般用于推送数据给服务器（给服务器多，获取少） -&gt;请求主体传参 PUT:一般用于给服务器增加资源文件（上传图片功能） DELETE:一般用于从服务器删除资源文件 HEAD:一般用于获取服务器响应头信息 这些请求方式不管是哪一种都可以向服务器获得或者传递数据，且从本质意义上无区别，只是行业内被开发者人约定俗成了各自不同的用处，并非标准。*/xhr.onreadystatechange = function () &#123; //绑定事件 if (xhr.readyState === 2) &#123; // xhr.getResponseHeader=&gt;客户端获取服务器的响应头信息 var time = xhr.getResponseHeader(&quot;Date&quot;); console.log(time); //输出的为格林尼治时间（GMT） console.log(new Date(time)); //输出为中国标准时间（GMT+0800） &#125; &#125;xhr.send(null);]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX中的HTTP请求方式]]></title>
    <url>%2F2018%2F10%2F07%2FHTTP-METHOD%2F</url>
    <content type="text"><![CDATA[HTTP METHODHTTP常用的几种请求方式： 1.GET 2.POST 3.PUT 4.DELETE 5.HEAD 这些请求方式不管是哪一种都可以向服务器请求获取数据或者传递数据，从本质上无区别，只是在行业内被开发人员约定俗成各自不同的用处，并非是一种标准。 方法分析1.GET:一般用于从服务器获取数据（给服务器数据少，获取数据多，此方法最为常用） 2.POST:一般用于推送数据给服务器（给服务器多，获取数据少） 3.PUT：一般用于向服务器传递资源文件（上传图片功能） 4.DELETE:一般用于删除服务器资源文件 5.HEAD:一般用于获取服务器响应头信息 GET PK POST传递方式： GET:向服务器传递内容一般通过&quot;URL问号传参方式&quot; xhr.open(&quot;GET&quot;,&quot;/getlist?a=2&amp;num=4&quot;,true); POST:向服务器传递内容一般通过&quot;请求主体的方式&quot; xhr.open(&quot;POST&quot;,&quot;/postlist&quot;,true); xhr.send(&apos;{&quot;name&quot;:&quot;fang&quot;,&quot;age&quot;:&quot;22&quot;}&apos;); //传递的为JSON对象格式的字符串 大小问题： GET请求传递给服务器的内容存在大小限制，而POST理论上无限制（实际一般最大2MB） 原因：GET是通过URL传参形式，而每个浏览器对URL长度有限制，谷歌8KB，火狐7KB，IE2KB,所以当兼容IE情况下最大上传2KB大小内容。 缓存问题： GET请求会出现缓存 =&gt; 因为请求地址与传参相同（不一定是304），POST请求无缓存 在项目中我们的GET请求一般不允许出现缓存 =&gt; “清除缓存” =&gt; 改变URL =&gt; 在URL末尾追加一个随机数 =&gt; xhr.open(&quot;GET&quot;,&quot;/getlist?a=2&amp;num=5&amp;_=&quot;+Math.random(),true); 安全问题： 一般来说GET不安全（URL传参）,而POST相对安全 实际当攻击者想攻击时都不安全]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式（发布/订阅模式）]]></title>
    <url>%2F2018%2F10%2F02%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。 说的简单些，就是在数据发生改变时，对应的处理函数自动执行。维基的定义中涉及到了主动发出通知，按照这种方式，在angularJS中的事件广播更是中规中矩，但是其缺点是代码的可维护性较差。那么如果不进行主动通知，而是在进行对象属性值设置时，调用相关的处理函数，也可达到同等效果。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 页面加载时自动执行 var Observer = (function() &#123; // 为了防止消息被外部修改，将消息变量设为私有变量 var _message = &#123;&#125;; return &#123; // 注册信息接口 regist: function(type, fn) &#123; // 判断消息类型是否存在 if (typeof _message[type] === &apos;undefined&apos;) &#123; // 将动作推送到消息队列中执行 _message[type] = [fn]; &#125; else &#123; // 将动作方法推入到对应类型的队列中 _message[type].push(fn); &#125; &#125;, // 发布消息接口 fire: function(type, args) &#123; //如果该消息没有被注册，直接结束 if (!_message[type]) return; var events = &#123; type: type, //消息的类型 args: args || &#123;&#125; //消息所携带的数据 &#125; i = 0, //消息循环变量 len = _message[type].length; //消息动作的长度 for (; i &lt; len; i++) &#123; //依次执行注册消息所对应的动作序列 _message[type][i].call(this, events); &#125; &#125;, // 移除信息接口 remove: function(type, fn) &#123; // 如果消息队列存在 if (_message[type] instanceof Array) &#123; //从最后一个消息动作开始遍历 var i = _message[type].length - 1; for (; i &gt;= 0; i--) &#123; _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1); &#125; &#125; &#125; &#125; &#125;)(); //订阅消息 Observer.regist(&apos;news&apos;, function(e) &#123; console.log(e.type, e.args.msg); &#125;); Observer.regist(&apos;weather&apos;, function(e) &#123; console.log(e.args.title); console.log(e.args.msg); &#125;); Observer.regist(&apos;weather&apos;, function(e) &#123; console.log(e.args.title); console.log(e.args.msg); &#125;); //发布消息 Observer.fire(&apos;news&apos;, &#123; msg: &apos;新闻主体内容&apos; &#125;); Observer.fire(&apos;weather&apos;, &#123; title: &apos;杭州天气&apos;, msg: &apos;晴转多云 21-36°C&apos; &#125;); Observer.fire(&apos;weather&apos;, &#123; title: &apos;上海天气&apos;, msg: &apos;晴转多云 22-36°C&apos; &#125;);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX兼容与惰性思想]]></title>
    <url>%2F2018%2F09%2F28%2FAJAX%2F</url>
    <content type="text"><![CDATA[JS编程技巧:惰性思想所谓的惰性思想可以简单地理解为:只执行一次可以搞定的事，绝不执行多次。 惰性思想代码块:12345678910111213141516var utils=(function()&#123; var flag=&quot;getComputedStyle&quot; in window; //若返回true则为标准浏览器，false为IE8及以下浏览器 function getCss()&#123; if(flag)&#123; //因为以上已判断此浏览器结果并保存,直接使用flag而不需要用window.getComputedStyle判断 &#125;else&#123; &#125; &#125; return&#123; getCss:getCss; &#125;&#125;)()utils.getCss(); utils.getCss();utils.getCss(); 惰性思想创建AJAX对象利用函数创建且兼容所有浏览器 源代码1234567891011121314151617181920212223242526272829303132333435363738var createXHR = function () &#123; var xhr = null, flag=false, //判断浏览器是否支持AJAX // 定义一个数组用于存放创建AJAX对象的各种方法 arr = [ function () &#123; return new XMLHttpRequest(); //只兼容IE7及以上 &#125;, // 以下三种方法兼容低版本浏览器 function () &#123; return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;, function () &#123; return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125;, function () &#123; return new ActiveXObject(&quot;Msxml3.XMLHTTP&quot;); &#125; ]; // 遍历这个数组中的小方法,当可用时即可取用 for (var i = 0; i &lt; arr.length; i++) &#123; var curFn = arr[i]; //获取当前遍历到的小方法 try &#123; // 本次循环获取的方法执行没有报错：说明此方法可用，下次直接执行此小方法即可=&gt;将createXHR重写为此小方法 xhr = curFn(); createXHR = curFn; flag = true; //浏览器可兼容AJAX则为true; break; //结束循环 &#125; catch (e) &#123; //本次获取的方法执行报错则继续循环遍历下一个方法 &#125; if (!flag) &#123; throw new Error(&quot;please updata your brower&quot;); //浏览器不支持AJAX时抛出错误 &#125; &#125; return xhr;&#125;;]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转的八卦图]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%97%8B%E8%BD%AC%E7%9A%84%E5%85%AB%E5%8D%A6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[利用JS或CSS3结合Canvas实现八卦图旋转]]></content>
      <categories>
        <category>Canvas</category>
        <category>JavaScript</category>
        <category>Css</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现文字跑马灯]]></title>
    <url>%2F2018%2F09%2F17%2F%E8%B7%91%E9%A9%AC%E7%81%AF%2F</url>
    <content type="text"><![CDATA[跑马灯思想所谓的跑马灯即类似于循环播放的通知告示等等效果。 主要利用元素嵌套产生的横向滚动条来控制循环滚动。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;跑马灯&lt;/title&gt; &lt;style&gt; #box&#123; background: pink; border: 1px dashed black; width: 608px; height: 20px; margin: 0 auto; &#125; #begin&#123; white-space: nowrap; float: left; &#125; #end&#123; white-space: nowrap; &#125; #movebox&#123; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;movebox&quot;&gt; &lt;div id=&quot;begin&quot;&gt; &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。 &lt;/div&gt; &lt;div id=&quot;end&quot;&gt; &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var movebox=document.getElementById(&apos;movebox&apos;); var begin=document.getElementById(&apos;begin&apos;); var beginWidth=window.getComputedStyle(begin,null).width; //获取元素宽度 自带单位（px） // console.log(beginWidth); //string类型 var beginw=beginWidth.replace(/px/,&quot;&quot;); //去除px单位 // console.log(beginw); var timer=window.setInterval(function()&#123; var curLeft=movebox.scrollLeft; //获取当前加之前的scrollleft值 movebox.scrollLeft=curLeft+1; //每隔10毫秒就使文字盒子水平滚动条在当前值上加1 var newLeft=movebox.scrollLeft; //获取当前加之后的left值console.log(newLeft); // 当scrollLeft值大于等于第一个div宽度时重置位置 if(newLeft&gt;=beginw)&#123; movebox.scrollLeft=0; &#125; &#125;,10)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇了解一下]]></title>
    <url>%2F2018%2F09%2F15%2F%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[利用Canvas与JavaScript实现贪吃蛇]]></content>
      <categories>
        <category>Canvas</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现回到页面顶部]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%2F</url>
    <content type="text"><![CDATA[实现效果1.右下角按钮回到顶部(点击后按钮消失，随即页面滑动到顶部;页面下拉距离超过一屏幕显示回到顶部按钮，反之按钮消失) 2.列表hover时显示随机颜色(利用时间委托机制) 3.点击左侧列表，页面滑动到对应模块(通过获取所点击列表的ID值滑动到对应CLASS值相同的模块) 点击查看源代码 代码分析回到顶部按钮1.获取当前scrollTop距离（var distance=document.documentElement.scrollTop||document.body.scrollTop） 2.总时间(var timer=500;单位：ms) 总共需要运动500ms 3.频率( var frequency=10;单位：ms) 每10ms运动一次 4.步长(var step=distance/timer*frequency) 每毫秒运动距离*频率=每一次运动所需步长 回到顶部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344var span = document.getElementsByTagName(&apos;span&apos;)[0];var i = document.getElementsByTagName(&apos;i&apos;)[0];var timer = 1000; //总时间var frequency = 5; //频率window.onscroll = show;function show() &#123; var dis = document.documentElement.scrollTop || document.body.scrollTop; var windis = window.screen.height; //屏幕分辨率高度 // console.log(windis); //当前滚动条距离大于一个屏幕高度时显示回到顶部按钮 if (dis &gt;= windis) &#123; span.style.display = &apos;block&apos;; i.style.display = &apos;block&apos;; &#125; else &#123; //当前滚动条距离小于一个屏幕高度时隐藏回到顶部按钮 span.style.display = &apos;none&apos;; i.style.display = &apos;none&apos;; &#125;&#125;;span.addEventListener(&apos;click&apos;, function (e) &#123; span.style.display = &apos;none&apos;; //单击后虽然设置为隐藏，但是由于滚动条顶部距离大于屏幕高度又触发上一个事件，使其又显示，所以当点击时需要阻止上一个事件发生； i.style.display = &apos;none&apos;; window.onscroll = null; //点击后阻止前一个DOM 0级事件 二级事件无法用此方法阻止 e = e || event; var disTop = document.documentElement.scrollTop || document.body.scrollTop; //获取运动前滚动条顶部距离 var step = (disTop / timer) * frequency; //步长 //定时器：每隔一定频率运动距离 var intime = window.setInterval(function () &#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离 if (curTop === 0) &#123; window.clearInterval(intime); //当距离为0时清除定时器 window.onscroll = show; return; //中断执行 &#125; else &#123; curTop -= step; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长 &#125; //每隔frequency时间设置一次滚动条距离 document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;, frequency);&#125;); 列表随机颜色1.利用事件委托机制给父级DIV加一个mouseover事件 2.mouseover在其子对象li上时触发事件，获取触发事件的目标(var elem = e.target;),对此目标进行操作 3.定义一个数组存放十六进制数，用于组成随机十六进制颜色，生成6个随机数(0-15)作为数组下标，将对应值存入一个空数组并转为字符串，即为十六进制颜色。 随机颜色代码12345678910111213141516171819202122232425var items = document.getElementsByTagName(&apos;li&apos;);var ul = document.getElementsByTagName(&apos;ul&apos;);// console.log(ul[0]);//事件委托：给父元素添加触发事件ul[0].addEventListener(&apos;mouseover&apos;, function (e) &#123; e = e || event; var elem = e.target; //获取目标 elem.style.background = null; // 每一次触发事件都先初始化 var num = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; //十六进制颜色 var colorNum = []; do &#123; var randomNum = Math.floor(Math.random() * 16); //0-15 //随机的0-15之间的一个数字作为十六进制数组下标 colorNum.push(num[randomNum]); &#125; while (colorNum.length &lt; 6); //将获取的6个随机数到空数组 // console.log(colorNum); var colorstr = colorNum.join(&apos;&apos;); //转为字符串 // console.log(colorstr); elem.style.background = &quot;#&quot; + colorstr; //设置随机颜色&#125;);//鼠标离开时清空颜色ul[0].addEventListener(&apos;mouseout&apos;, function (e) &#123; e = e || event; var elem = e.target; elem.style.background = null;&#125;); 滑动模块1.与获取随机颜色原理相同，需要利用事件委托，通过给父元素DIV加点击事件获取目标事件 2.获取所点击目标的ID值，寻找模块中CLASS值与ID值相同的模块，并获取其距离顶部高度 3.需要设置过渡动画效果则与按钮部分相同需要设置运动总时间、总距离、频率等 滑动模块代码12345678910111213141516171819202122232425262728293031ul[0].addEventListener(&apos;click&apos;, function (e) &#123; e = e || event; var liElem = e.target; //利用时间委托获取目标 var liName = liElem.getAttribute(&apos;id&apos;) //获取目标id值 var divName = document.getElementsByClassName(liName)[0]; //获取对应名称的DIV模块元素 var top = divName.offsetTop; //获取对应的滚动条高度 var timer = 500; //总时间 var frequencytwo = 3; //频率 if (top &lt; timer) &#123; top += 500; &#125; var stepgo = (top / timer) * frequencytwo; //步长 //定时器：每隔一定频率运动距离 var intn = window.setInterval(function () &#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离 if (curTop === top) &#123; window.clearInterval(intn); //当两者相同时清除定时器 return; //中断执行 &#125; if (curTop &gt; top) &#123; curTop -= stepgo; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长 &#125; if (curTop &lt; top) &#123; curTop += stepgo; &#125; //每隔frequency时间设置一次滚动条距离 document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;, frequencytwo);&#125;); 本人才疏学浅，暂时只能展示所知显浅部分，有误或可改进之处请留言告知 ◕‿-]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
