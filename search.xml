<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[观察者模式（发布/订阅模式）]]></title>
    <url>%2F2018%2F10%2F02%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。 说的简单些，就是在数据发生改变时，对应的处理函数自动执行。维基的定义中涉及到了主动发出通知，按照这种方式，在angularJS中的事件广播更是中规中矩，但是其缺点是代码的可维护性较差。那么如果不进行主动通知，而是在进行对象属性值设置时，调用相关的处理函数，也可达到同等效果。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 页面加载时自动执行 var Observer = (function() &#123; // 为了防止消息被外部修改，将消息变量设为私有变量 var _message = &#123;&#125;; return &#123; // 注册信息接口 regist: function(type, fn) &#123; // 判断消息类型是否存在 if (typeof _message[type] === &apos;undefined&apos;) &#123; // 将动作推送到消息队列中执行 _message[type] = [fn]; &#125; else &#123; // 将动作方法推入到对应类型的队列中 _message[type].push(fn); &#125; &#125;, // 发布消息接口 fire: function(type, args) &#123; //如果该消息没有被注册，直接结束 if (!_message[type]) return; var events = &#123; type: type, //消息的类型 args: args || &#123;&#125; //消息所携带的数据 &#125; i = 0, //消息循环变量 len = _message[type].length; //消息动作的长度 for (; i &lt; len; i++) &#123; //依次执行注册消息所对应的动作序列 _message[type][i].call(this, events); &#125; &#125;, // 移除信息接口 remove: function(type, fn) &#123; // 如果消息队列存在 if (_message[type] instanceof Array) &#123; //从最后一个消息动作开始遍历 var i = _message[type].length - 1; for (; i &gt;= 0; i--) &#123; _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1); &#125; &#125; &#125; &#125; &#125;)(); //订阅消息 Observer.regist(&apos;news&apos;, function(e) &#123; console.log(e.type, e.args.msg); &#125;); Observer.regist(&apos;weather&apos;, function(e) &#123; console.log(e.args.title); console.log(e.args.msg); &#125;); Observer.regist(&apos;weather&apos;, function(e) &#123; console.log(e.args.title); console.log(e.args.msg); &#125;); //发布消息 Observer.fire(&apos;news&apos;, &#123; msg: &apos;新闻主体内容&apos; &#125;); Observer.fire(&apos;weather&apos;, &#123; title: &apos;杭州天气&apos;, msg: &apos;晴转多云 21-36°C&apos; &#125;); Observer.fire(&apos;weather&apos;, &#123; title: &apos;上海天气&apos;, msg: &apos;晴转多云 22-36°C&apos; &#125;);]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX兼容与惰性思想]]></title>
    <url>%2F2018%2F09%2F28%2FAJAX%2F</url>
    <content type="text"><![CDATA[JS编程技巧:惰性思想所谓的惰性思想可以简单地理解为:只执行一次可以搞定的事，绝不执行多次。 惰性思想代码块:12345678910111213141516var utils=(function()&#123; var flag=&quot;getComputedStyle&quot; in window; //若返回true则为标准浏览器，false为IE8及以下浏览器 function getCss()&#123; if(flag)&#123; //因为以上已判断此浏览器结果并保存,直接使用flag而不需要用window.getComputedStyle判断 &#125;else&#123; &#125; &#125; return&#123; getCss:getCss; &#125;&#125;)()utils.getCss(); utils.getCss();utils.getCss(); 惰性思想创建AJAX对象利用函数创建且兼容所有浏览器 源代码1234567891011121314151617181920212223242526272829303132333435363738var createXHR = function () &#123; var xhr = null, flag=false, //判断浏览器是否支持AJAX // 定义一个数组用于存放创建AJAX对象的各种方法 arr = [ function () &#123; return new XMLHttpRequest(); //只兼容IE7及以上 &#125;, // 以下三种方法兼容低版本浏览器 function () &#123; return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;, function () &#123; return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125;, function () &#123; return new ActiveXObject(&quot;Msxml3.XMLHTTP&quot;); &#125; ]; // 遍历这个数组中的小方法,当可用时即可取用 for (var i = 0; i &lt; arr.length; i++) &#123; var curFn = arr[i]; //获取当前遍历到的小方法 try &#123; // 本次循环获取的方法执行没有报错：说明此方法可用，下次直接执行此小方法即可=&gt;将createXHR重写为此小方法 xhr = curFn(); createXHR = curFn; flag = true; //浏览器可兼容AJAX则为true; break; //结束循环 &#125; catch (e) &#123; //本次获取的方法执行报错则继续循环遍历下一个方法 &#125; if (!flag) &#123; throw new Error(&quot;please updata your brower&quot;); //浏览器不支持AJAX时抛出错误 &#125; &#125; return xhr;&#125;;]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转的八卦图]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%97%8B%E8%BD%AC%E7%9A%84%E5%85%AB%E5%8D%A6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[利用JS或CSS3结合Canvas实现八卦图旋转]]></content>
      <categories>
        <category>Canvas</category>
        <category>JavaScript</category>
        <category>Css</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现文字跑马灯]]></title>
    <url>%2F2018%2F09%2F17%2F%E8%B7%91%E9%A9%AC%E7%81%AF%2F</url>
    <content type="text"><![CDATA[跑马灯思想所谓的跑马灯即类似于循环播放的通知告示等等效果。 主要利用元素嵌套产生的横向滚动条来控制循环滚动。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;跑马灯&lt;/title&gt; &lt;style&gt; #box&#123; background: pink; border: 1px dashed black; width: 608px; height: 20px; margin: 0 auto; &#125; #begin&#123; white-space: nowrap; float: left; &#125; #end&#123; white-space: nowrap; &#125; #movebox&#123; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;movebox&quot;&gt; &lt;div id=&quot;begin&quot;&gt; &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。 &lt;/div&gt; &lt;div id=&quot;end&quot;&gt; &lt;span style=&quot;color:red;&quot;&gt;感言: &lt;/span&gt;梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。 山路曲折盘旋，但毕竟朝着顶峰延伸。 只有登上山顶，才能看到那边的风光。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var movebox=document.getElementById(&apos;movebox&apos;); var begin=document.getElementById(&apos;begin&apos;); var beginWidth=window.getComputedStyle(begin,null).width; //获取元素宽度 自带单位（px） // console.log(beginWidth); //string类型 var beginw=beginWidth.replace(/px/,&quot;&quot;); //去除px单位 // console.log(beginw); var timer=window.setInterval(function()&#123; var curLeft=movebox.scrollLeft; //获取当前加之前的scrollleft值 movebox.scrollLeft=curLeft+1; //每隔10毫秒就使文字盒子水平滚动条在当前值上加1 var newLeft=movebox.scrollLeft; //获取当前加之后的left值console.log(newLeft); // 当scrollLeft值大于等于第一个div宽度时重置位置 if(newLeft&gt;=beginw)&#123; movebox.scrollLeft=0; &#125; &#125;,10)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇了解一下]]></title>
    <url>%2F2018%2F09%2F15%2F%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
    <content type="text"><![CDATA[利用Canvas与JavaScript实现贪吃蛇]]></content>
      <categories>
        <category>Canvas</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现回到页面顶部]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%2F</url>
    <content type="text"><![CDATA[实现效果1.右下角按钮回到顶部(点击后按钮消失，随即页面滑动到顶部;页面下拉距离超过一屏幕显示回到顶部按钮，反之按钮消失) 2.列表hover时显示随机颜色(利用时间委托机制) 3.点击左侧列表，页面滑动到对应模块(通过获取所点击列表的ID值滑动到对应CLASS值相同的模块) 点击查看源代码 代码分析回到顶部按钮1.获取当前scrollTop距离（var distance=document.documentElement.scrollTop||document.body.scrollTop） 2.总时间(var timer=500;单位：ms) 总共需要运动500ms 3.频率( var frequency=10;单位：ms) 每10ms运动一次 4.步长(var step=distance/timer*frequency) 每毫秒运动距离*频率=每一次运动所需步长 回到顶部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344var span = document.getElementsByTagName(&apos;span&apos;)[0];var i = document.getElementsByTagName(&apos;i&apos;)[0];var timer = 1000; //总时间var frequency = 5; //频率window.onscroll = show;function show() &#123; var dis = document.documentElement.scrollTop || document.body.scrollTop; var windis = window.screen.height; //屏幕分辨率高度 // console.log(windis); //当前滚动条距离大于一个屏幕高度时显示回到顶部按钮 if (dis &gt;= windis) &#123; span.style.display = &apos;block&apos;; i.style.display = &apos;block&apos;; &#125; else &#123; //当前滚动条距离小于一个屏幕高度时隐藏回到顶部按钮 span.style.display = &apos;none&apos;; i.style.display = &apos;none&apos;; &#125;&#125;;span.addEventListener(&apos;click&apos;, function (e) &#123; span.style.display = &apos;none&apos;; //单击后虽然设置为隐藏，但是由于滚动条顶部距离大于屏幕高度又触发上一个事件，使其又显示，所以当点击时需要阻止上一个事件发生； i.style.display = &apos;none&apos;; window.onscroll = null; //点击后阻止前一个DOM 0级事件 二级事件无法用此方法阻止 e = e || event; var disTop = document.documentElement.scrollTop || document.body.scrollTop; //获取运动前滚动条顶部距离 var step = (disTop / timer) * frequency; //步长 //定时器：每隔一定频率运动距离 var intime = window.setInterval(function () &#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离 if (curTop === 0) &#123; window.clearInterval(intime); //当距离为0时清除定时器 window.onscroll = show; return; //中断执行 &#125; else &#123; curTop -= step; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长 &#125; //每隔frequency时间设置一次滚动条距离 document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;, frequency);&#125;); 列表随机颜色1.利用事件委托机制给父级DIV加一个mouseover事件 2.mouseover在其子对象li上时触发事件，获取触发事件的目标(var elem = e.target;),对此目标进行操作 3.定义一个数组存放十六进制数，用于组成随机十六进制颜色，生成6个随机数(0-15)作为数组下标，将对应值存入一个空数组并转为字符串，即为十六进制颜色。 随机颜色代码12345678910111213141516171819202122232425var items = document.getElementsByTagName(&apos;li&apos;);var ul = document.getElementsByTagName(&apos;ul&apos;);// console.log(ul[0]);//事件委托：给父元素添加触发事件ul[0].addEventListener(&apos;mouseover&apos;, function (e) &#123; e = e || event; var elem = e.target; //获取目标 elem.style.background = null; // 每一次触发事件都先初始化 var num = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; //十六进制颜色 var colorNum = []; do &#123; var randomNum = Math.floor(Math.random() * 16); //0-15 //随机的0-15之间的一个数字作为十六进制数组下标 colorNum.push(num[randomNum]); &#125; while (colorNum.length &lt; 6); //将获取的6个随机数到空数组 // console.log(colorNum); var colorstr = colorNum.join(&apos;&apos;); //转为字符串 // console.log(colorstr); elem.style.background = &quot;#&quot; + colorstr; //设置随机颜色&#125;);//鼠标离开时清空颜色ul[0].addEventListener(&apos;mouseout&apos;, function (e) &#123; e = e || event; var elem = e.target; elem.style.background = null;&#125;); 滑动模块1.与获取随机颜色原理相同，需要利用事件委托，通过给父元素DIV加点击事件获取目标事件 2.获取所点击目标的ID值，寻找模块中CLASS值与ID值相同的模块，并获取其距离顶部高度 3.需要设置过渡动画效果则与按钮部分相同需要设置运动总时间、总距离、频率等 滑动模块代码12345678910111213141516171819202122232425262728293031ul[0].addEventListener(&apos;click&apos;, function (e) &#123; e = e || event; var liElem = e.target; //利用时间委托获取目标 var liName = liElem.getAttribute(&apos;id&apos;) //获取目标id值 var divName = document.getElementsByClassName(liName)[0]; //获取对应名称的DIV模块元素 var top = divName.offsetTop; //获取对应的滚动条高度 var timer = 500; //总时间 var frequencytwo = 3; //频率 if (top &lt; timer) &#123; top += 500; &#125; var stepgo = (top / timer) * frequencytwo; //步长 //定时器：每隔一定频率运动距离 var intn = window.setInterval(function () &#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; //获取滚动时当前滚动条距离 if (curTop === top) &#123; window.clearInterval(intn); //当两者相同时清除定时器 return; //中断执行 &#125; if (curTop &gt; top) &#123; curTop -= stepgo; //使当前滚动条距离每隔frequency时间在当前距离基础上减去原始步长 &#125; if (curTop &lt; top) &#123; curTop += stepgo; &#125; //每隔frequency时间设置一次滚动条距离 document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;, frequencytwo);&#125;); 本人才疏学浅，暂时只能展示所知显浅部分，有误或可改进之处请留言告知 ◕‿-]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
